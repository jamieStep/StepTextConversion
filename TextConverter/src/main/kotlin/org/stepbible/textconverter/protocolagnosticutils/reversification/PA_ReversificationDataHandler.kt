/******************************************************************************/
package org.stepbible.textconverter.protocolagnosticutils.reversification

import org.stepbible.textconverter.applicationspecificutils.IssueAndInformationRecorder
import org.stepbible.textconverter.applicationspecificutils.X_DataCollection
import org.stepbible.textconverter.nonapplicationspecificutils.configdata.ConfigData
import org.stepbible.textconverter.nonapplicationspecificutils.configdata.TranslatableFixedText
import org.stepbible.textconverter.nonapplicationspecificutils.debug.Dbg
import org.stepbible.textconverter.nonapplicationspecificutils.debug.Logger
import org.stepbible.textconverter.nonapplicationspecificutils.debug.Rpt
import org.stepbible.textconverter.nonapplicationspecificutils.miscellaneous.MiscellaneousUtils.convertNumberToRepeatingString
import org.stepbible.textconverter.nonapplicationspecificutils.ref.*
import org.stepbible.textconverter.nonapplicationspecificutils.shared.Language
import org.stepbible.textconverter.nonapplicationspecificutils.stepexception.StepExceptionWithStackTraceAbandonRun
import org.stepbible.textconverter.protocolagnosticutils.PA
import org.w3c.dom.Node
import java.io.File
import java.net.URL
import java.util.*


/******************************************************************************/
/**
 * Reads and stores reversification data and provides summary information about
 * it.
 *
 *
 *
 *
 *
 * ## About the data
 *
 * Each reversification row is made up of a number of named fields, and gives
 * rise to a single action.
 *
 * Not all rows are applicable to all texts.  Most rows have an associated
 * Test field, and the row applies only if all of the tests pass.  (Typical
 * tests include checking whether a given verse exists, whether a given verse is
 * the last in its owning chapter, or whether the content-length of two verses
 * stand in a particular relationship.)  The Test field may be empty, in which
 * case the test is assumed to pass.  Note that length tests applied to elided
 * verses always fail, because we have no way of determining the correct length
 * of an elided verse.
 *
 * All of this is taken into account automatically within the *process* method
 * here, so that by the time this method returns, the appropriate
 * reversification rows will have been selected for use by the caller.
 *
 * Note that the reversification processing may create subverses in some
 * cases.  osis2mod and JSword cannot handle subverses and they therefore need
 * to be removed from the output.  In view of this it may seem odd that details
 * of such verses are not available from the present class.  However, the
 * processing at large must remove *all* subverses, whether generated by
 * reversification or present in the raw text, so knowing which subverses
 * were generated specifically by reversification is of no value to it.
 *
 * @author ARA "Jamie" Jamieson
 */

/******************************************************************************/
object PA_ReversificationDataHandler: PA()
{
  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                                Public                                  **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  fun process (dataCollection: X_DataCollection)
  {
    extractCommonInformation(dataCollection, wantBibleStructure = true)
    load(dataCollection)
  }


  /****************************************************************************/
  /**
  * Returns a list of all accepted rows.
  *
  * @return List of accepted rows.
  */

  fun getSelectedRows () = m_SelectedRows


   /****************************************************************************/
   /**
   * Returns a map of lists -- keyed on book number, with each entry being the
   * full list of ReversificationDataRow's for that book.
   *
   * @return Mapped reversification details.
   */

   fun getSelectedRowsBySourceBook (): Map<Int, List<ReversificationDataRow>> = getSelectedRows().groupBy { it.sourceRef.getB() }


   /****************************************************************************/
   /**
   * Returns a list of ReversificationDataRow's associated with the book
   * represented by rootNode.
   *
   * @param rootNode Node representing the book of interest.
   * @return ReversificationDataRow's.
   */

   fun getSelectedRowsForBook (rootNode: Node): List<ReversificationDataRow>
   {
     val bookNo = m_FileProtocol.getBookNumber(rootNode)
     return getSelectedRows()
       .filter { bookNo == it.sourceRef.getB() }
   }


  /****************************************************************************/
  /**
  * Returns a string representation of all accepted rows.  Intended mainly for
  * debugging and, if recorded within the STEP repository package for the
  * module, to make it possible to identify modules with certain
  * characteristics.
  *
  * @return List of accepted rows.
  */

  fun getSelectedRowsAsStrings () = m_SelectedRows.map { it.toString() }





  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                              Data-load                                 **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  /* This section loads the data.  At the end of processing, m_SelectedRows
     contains a full collection of ReversificationDataRow entries, representing
     the reversification rows which have been selected.

     I also canonicalise the data while doing this.  This caters for several
     issues:

     - In some cases, it seems to me that information has been placed in one
       field which should really appear in a different one.

     - I parse some of the more complex fields into constituent elements.

     - The data does not handle scripture references in an entirely
       consistent manner.  Some follow USX.  Some _almost_ follow USX, but
       have slightly the wrong syntax.  I remedy the latter.

     - Also there are some places which contain things which are really
       intended to be scripture references, but which don't quite fit the
       mould because they need to be extended to carry information which doesn't
       naturally fit into a scripture reference.  I try to sort these out, such
       that if I need to convert these entries to vernacular form, I stand a
       better chance of doing so.
   */

  /****************************************************************************/
  /**
  * Controls the overall loading of the data.
  *
  * @param dataCollection Data to which the reversification data is to be
  *   applied.
  */

  private fun load (dataCollection: X_DataCollection)
  {
    Rpt.report(1, "Reading reversification data and checking applicability.  Data is normally taken from the online repository, so this may take a moment.")
    load_1(dataCollection)

    if (m_SelectedRows.isNotEmpty())
      IssueAndInformationRecorder.setRuntimeReversification()
  }


  /****************************************************************************/
  /* Locates the relevant data within the input file and then reads it in and
     arranges to parse and canonicalise it. */

  private fun load_1 (dataCollection: X_DataCollection)
  {
    /**************************************************************************/
    /* Make commonly-used items readily available. */

    m_DataCollection = dataCollection
    m_BibleStructure = dataCollection.getBibleStructure(wantCanonicalTextSize = true)
    m_FileProtocol = dataCollection.getFileProtocol()
    m_RuleEvaluator = PA_ReversificationRuleEvaluator(dataCollection)



    /**************************************************************************/
    /* Read the full data from the location determined by the configuration
       data.  Preferably this will be our online data repository, where the
       data can be guaranteed to be up to date.  But you can also use a local
       file, for example if that will help with testing. */

    val dataLocation = ConfigData["stepExternalDataPath_ReversificationData"]!!
    if (!dataLocation.startsWith("http")) Logger.warning("Running with local copy of reversification data.")
    val rawData = (if (dataLocation.contains("http")) URL(dataLocation).readText() else File(dataLocation).readText()).split("\n")



    /****************************************************************************/
    /* Used when Looks for a row containing a given piece of text.  Used to
       identify where the reversification data of interest to us starts and ends
       within the overall text. */

    fun findLine (data: List<String>, lookFor: String, startAt: Int): Int
    {
      val lookForLower = lookFor.lowercase()
      for (i in startAt..< data.size)
        if (data[i].lowercase().startsWith(lookForLower)) return i

      throw StepExceptionWithStackTraceAbandonRun("Guard row $lookFor missing from reversification data")
    }



    /**************************************************************************/
    /* I do at least make the assumption that the online data and any local
       copy will follow precisely the same format.  The data of interest is
       delimited by two markers, and then we need to remove from the resulting
       sublist comment lines (which start with '#'), blank lines, lines starting
       '=' (which at one point were used to underline headings), and lines
       starting with a single quote (which latterly has been used at the start
       of heading lines, so that they don't necessarily start with an equals
       sign as I think they used to.

       I keep a row count for debugging purposes -- it makes progress reporting
       more meaningful, and also makes it easier to determine which line is
       being processed if something goes wrong. */

    val ixLow = findLine(rawData, "#DataStart(Expanded)", 0)
    val ixHigh = findLine(rawData, "#DataEnd", ixLow)
    val filteredData = rawData.subList(ixLow + 1, ixHigh).map { it.trim() }.filterNot { it.startsWith('#') || it.isBlank() || it.startsWith('=') || it.startsWith('\'')  }
    Rpt.reportWithContinuation(level = 1, "Parsing reversification data (total of ${filteredData.size} rows) ...") { // Report progress in the same way as when processing books.
      var rowNumber = 0
      filteredData.forEach { loadRow(it, ++rowNumber) }
      Logger.announceAllAndTerminateImmediatelyIfErrors()
      debugOutputDebugData()
    }

    //Dbg.d(m_SelectedRows)
  }


  /****************************************************************************/
  /* Adds details of a single row, assuming it passes the relevant tests. */

  private fun loadRow (rawData: String, rowNumber: Int)
  {
    /**************************************************************************/
    //Dbg.d(rowNumber)
    //Dbg.d(rawData)
    //Dbg.dCont(rawData, "Gen.32:33")



    /**************************************************************************/
    if (rowNumber == 1000 * (rowNumber / 1000))
      Rpt.reportAsContinuation(rowNumber.toString())



    /**************************************************************************/
    /* Fields in the reversification row are tab-separated.  Split them out,
       create a ReversificationDataRow to hold the data.  The slightly odd code
       below works as follows:

       If we haven't yet initialised the column map, we can take it that the
       data we have read is correct -- we take it as-is, split it out, and
       that gives us all of the column names.

       If we _have_ initialised the column map, we may, on occasion, have a
       truncated row, if the reversification data should end with blank fields
       but they have been missed off.  In this case I add a load of trailing
       tabs to give the impression that the data is longer than it actually
       was, so that I'm guaranteed to have all the fields I need. */

    val fields = (if (ReversificationDataRow.headersInitialised()) rawData + "\t\t\t\t\t\t\t\t" else rawData).split("\t").map { it.trim() }.toMutableList()
    val rawRow = ReversificationDataRow(rowNumber)
    rawRow.fields = fields



    /**************************************************************************/
    /* If this row is actually the header row, we merely want to record what
       the headers are and map them to field numbers, but not store the row as
       if it where a data row. */

    if (!ReversificationDataRow.headersInitialised())
    {
      var n = -1
      fields.forEach { ReversificationDataRow.setHeader(it, ++n) }
      return
    }



    /**************************************************************************/
    /* We may want to ignore some rows.  The reversification data may, in a few
       cases, refer to books which actually do not exist in the USX naming
       scheme, and we can therefore never process them.  And if this is a
       debugging run, being applied only to selected books, we can ignore rows
       for any other books. */

    if (ignoreRow(rawRow))
      return



    /**************************************************************************/
    /* There are various anomalies in the data, or things which I'd prefer were
       represented differently.  Sort these out. */

    canonicaliseAndCorrectData(rawRow)



    /**************************************************************************/
    /* Checks that the row does actually apply, and performs miscellaneous
       additional processing -- things like parsing the NoteMarker and
       AncientVersions fields, which are quite complicated.  Returns null if
       the row is not accepted. */

    val processedRow = convertToProcessedForm(rawRow)
    if (null != processedRow)
      m_SelectedRows.add(processedRow)



    /**************************************************************************/
    /* May be useful for debugging. */

    if (null == processedRow)
      debugRecordReversificationRowRejected(rawRow)
    else
      debugRecordReversificationRowAccepted(processedRow)
  }


  /****************************************************************************/
  /* There are some inconsistencies / infelicities in the reversification data,
     and processing is easier if these are sorted out.  This method leaves
     the 'fields' array of dataRow unchanged.  However, the action, sourceRef
     and standardRef fields may be set using revised copies of these fields,
     so as to correct the inconsistencies.

     This does mean that these specific individual fields may not exactly
     mimic the content of the 'fields' array, but on the other hand it means
     that the 'fields' array is still as read from the reversification data,
     which may simplify debugging. */

  private fun canonicaliseAndCorrectData (dataRow: ReversificationDataRow)
  {
    /**************************************************************************/
    /* Get the canonical form of the action name.  This is the form as supplied,
       but with the '*' used to mark Moves removed, spaces suppressed and
       converted to lower case. */
   dataRow["Action"] = dataRow["Action"].replace(" ", "").lowercase()
   dataRow.isMove = "*" in dataRow["Action"]
    val x = dataRow["Action"].replace("*", "").replace(" ", "").lowercase()
    dataRow.action = x




    /**************************************************************************/
    /* There are several parts to sorting out the references.  First step is to
       convert them to USX form (unfortunately they aren't in that form in the
       reversification data -- or at least, not the source or standard ref). */

    var sourceRef   = usxifyFromStepFormat(dataRow["SourceRef"])
    var standardRef = usxifyFromStepFormat(dataRow["StandardRef"])
    dataRow.sourceIsPsalmTitle = "title" in sourceRef.lowercase()



    /**************************************************************************/
    /* If either sourceRef or standardRef refer to subverse zero, the subverse
       can be dropped -- USX doesn't recognise subverse zero, so we won't have
       anything marked as such in the input (it will just be the verse), and
       we don't want to create anything like that in the output. */

    if (sourceRef.endsWith(".0"))
      sourceRef = sourceRef.replace(".0", "")

    if (standardRef.endsWith(".0"))
      standardRef = standardRef.replace(".0", "")



    /**************************************************************************/
    /* It is rather convenient to treat anything involving a title as actually
       involving a verse.  I distinguish this verse by giving it a special verse
       number (499 at the time of writing).

       One downside to using this is that if I fabricate a canonical title,
       it's going to come out right at the end of the chapter, so I need to
       move it back when I've finished processing.  From that point of view,
       using v0 as the special marker would be better.  But the problem is that
       everything is set up to believe that a reference whose verse number is
       zero is a chapter reference, and that makes life very difficult.

       Of course, this will only work if I pre-process the text to change any
       existing canonical titles to be of this same form (and if I change them
       back again before going on to generate the OSIS).  Clearly this is a
       complication, both in terms of having to do it, and also in terms of the
       confusion it's likely to cause when it comes to maintaining the code.  I
       _think_ it's worth it, though. */

    if ("title" in standardRef.lowercase())
    {
      standardRef = standardRef.replaceFirst("(?i)title".toRegex(), RefBase.C_TitlePseudoVerseNumber.toString())
      if ("title" !in sourceRef.lowercase()) // If, rather than an existing title, we're using verses to create the title, make it appear they are creating subverses of the special verse.
      {
        val sourceVerse = Ref.rdUsx(sourceRef).getV()
        standardRef += convertNumberToRepeatingString(sourceVerse, 'a', 'z')
      }
    }

    if ("title" in sourceRef.lowercase())
      sourceRef = sourceRef.replace("(?i)title".toRegex(), RefBase.C_TitlePseudoVerseNumber.toString())



    /**************************************************************************/
    dataRow.sourceRef = Ref.rdUsx(sourceRef)
    dataRow.standardRef = Ref.rdUsx(standardRef)
    dataRow.sourceRefAsRefKey   = dataRow.sourceRef.toRefKey()
    dataRow.standardRefAsRefKey = dataRow.standardRef.toRefKey()
  }


  /****************************************************************************/
  /* Identifies rows which should not be processed. */

  private fun ignoreRow (dataRow: ReversificationDataRow): Boolean
  {
    /**************************************************************************/
    /* The reversification data contains a few rows for 4Esdras.  We need to
       weed these out, because the USX scheme doesn't recognise this book. */

    val sourceRef = dataRow["SourceRef"]
    if (sourceRef.contains("4es", ignoreCase = true))
      return true



    /**************************************************************************/
    /* For debug purposes it is often convenient to process only a few books.
       We need to ignore reversification data for any where the source
      reference is for a book which we are not processing. */

    return !Dbg.wantToProcessBook(sourceRef.substring(0, 3))
  }


  /****************************************************************************/
  /* Canonicalises the contents of a single row and adds it to the various
     collections if it passes any applicability tests.  Note that by the
     time we get here, we can be sure there are no blank rows or comment rows
     in the data.

     You may observe that there are a number of points within the processing
     where it becomes apparent that the row being processed does not apply to
     the present text, and from an efficiency point of view it would make sense
     to abandon further processing at that point.  However, it is convenient to
     stick with it to the end, because the processed form of the row may be
     useful for debugging purposes. */

  private fun convertToProcessedForm (dataRow: ReversificationDataRow): ReversificationDataRow?
  {
    /**************************************************************************/
    //Dbg.d(5406 == dataRow.rowNumber)



    /**************************************************************************/
    /* Check to see if the row actually applies at all.  There are several parts
       to this.

       First 'Does this row apply?' check: Does it relate to a book which we are
       actually processing on this run?  (It might not do if we're dealing with
       a partial text, or have opted to process only selected books, perhaps to
       speed up debugging.) */

    if (!m_BibleStructure!!.bookExists(dataRow.sourceRef))
      return null



    /**************************************************************************/
    /* Second 'Does this row apply?' check: If the Test field contains anything,
       does the rule pass? */

    val ruleData = dataRow["Tests"]
    if (!m_RuleEvaluator.rulePasses(ruleData, dataRow.toString()))
      return null



    /**************************************************************************/
    setCalloutAndFootnoteLevel(dataRow)
    setAncientVersions(dataRow["Ancient Versions"])



    /**************************************************************************/
    return dataRow
  }


  /****************************************************************************/
  /* New format callout / footnote processing.

     Callout / footnote processing is driven by the NoteMarker field.  Note
     that footnotes are suppressed when processing a copyright text.  In what
     follows I do not repeat this -- I explain what happens if we _are_
     generating footnotes.

     This NoteMarker field contains a number of separate pieces of information.
     A typical entry looks like

       Acd. (25)^[3:1a]

     The 'Acd' portion may be replaced by any of the following:

     * Nec: The associated footnote is relevant to _any_ audience, academic or
       not.

     * Opt: ??

     * Inf: Inf appears only upon IfEmptyVerse rows in the reversification data.
       If the standard verse is already present in the supplied text and the
       translators have applied a footnote to it, we assume that the footnote
       explains the fact that the verse is empty, and we do not add a footnote
       of our own.  If the standard verse is present in the supplied text but
       does not have a footnote, then we add one of our own.  If the standard
       verse is missing from the supplied text, we generate an empty verse and
       give it a footnote.

     * Acd: The associated footnote is likely to be of interest only if the
       module we are generating is aimed at an academic audience.  It is
       suppressed when generating modules for a non-academic audience.


    Returning to the sample NoteMarker field above:

       Acd. (25)^[3:1a]

    The portion after the 'XXX.' comprises one or two verse references.  The
    parenthesised part is always present (I think) and is always just a single
    verse number (I think).

    The portion after the up-arrow is not always present.  When it _is_
    present, it may or may not be enclosed in square brackets.  And it may be
    a single verse number, or it may be more than that.

    These items were included at a time when we were intending to do
    conversion-time reversification and wanted to include verse numbers in
    the text to try to emphasise continuity with the text as supplied.  At
    present it looks rather less likely that we will be doing conversion-time
    reversification; and even if we do, our original plan (to give one or
    other of these verse numbers as a callout) has been thwarted because STEP
    always renders callouts as down-arrows.

    Since I have forgotten the precise details of these items, therefore, and
    since at present we aren't using them, I don't propose to try to give
    precise details of the way they are supposed to be used.
   */

  private const val C_FootnoteLevelNec = 'N'
  private const val C_FootnoteLevelAcd = 'A'
  private const val C_FootnoteLevelOpt = 'O'
  private const val C_FootnoteLevelInf = 'I'

  private fun setCalloutAndFootnoteLevel (dataRow: ReversificationDataRow)
  {
    /**************************************************************************/
    var x = dataRow["NoteMarker"]
    when (x.trim().substring(0, 2).lowercase())
    {
      "ne" -> dataRow.footnoteLevel = C_FootnoteLevelNec // If footnotes are permitted at all, this should always be output, regardless of whether this is an academic or non-academic run.
      "ac" -> dataRow.footnoteLevel = C_FootnoteLevelAcd // Output on academic runs only.
      "op" -> dataRow.footnoteLevel = C_FootnoteLevelOpt // Not exactly sure what this means, but it is used in a slightly complicated way.
      "in" -> dataRow.footnoteLevel = C_FootnoteLevelInf // Used selectively on empty verses.
      else -> Logger.error("Reversification invalid note level: " + x[0])
    }

    val ix = x.indexOf(".")
    x = x.substring(ix + 1)



    /**************************************************************************/
    val cd = CalloutDetails()
    dataRow.calloutDetails = cd



    /**************************************************************************/
    var s = x.replace("\\s+".toRegex(), "").replace("^", "") // Don't want spaces or the up-arrow which indicates that the footnote is to be included (it always is).
    if (s.contains("("))
    {
      val xx = s.split("(")[1].split(")")[0]
      s = s.replace("\\(.+?\\)".toRegex(), "")
      if (xx[0].lowercase() == "t")
        cd.standardVerseIsCanonicalTitle = true
      else
        cd.standardVerse = Ref.rdUsx(usxifyFromStepFormat(xx), null, "v")
    }



    /**************************************************************************/
    if (s.contains("["))
    {
      var xx = s.split("[")[1].split("]")[0]
      s = s.replace("\\[.+?]".toRegex(), "")

      if (xx.startsWith("+"))
      {
        cd.alternativeRefCollectionHasPrefixPlusSign = true
        xx = xx.substring(1)
      }

      if (xx.contains("+"))
      {
        cd.alternativeRefCollectionHasEmbeddedPlusSign = true
        xx = xx.replace("+", ",")
      }

      cd.alternativeRefCollection = RefCollection.rdUsx(usxifyFromStepFormat(xx), null, "v")
    }



    /**************************************************************************/
    if (s.isNotEmpty())
      cd.sourceVerseCollection = RefCollection.rdUsx(usxifyFromStepFormat(s), null, "v")
  }





  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                               Utilities                                **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  /**
   * The reversification data uses its own formats for references.  It's
   * convenient to convert this to USX for processing because I already have
   * code to handle USX.
   *
   * @param theStepRef Reference in STEP format.
   * @return String representation of an equivalent reference in USX format.
   *         Note that this may differ from the original in respect of
   *         whitespace, separators, etc, but since we need it only for
   *         parsing, that's not an issue.
   */

  fun usxifyFromStepFormat (theStepRef: String): String
  {
    /**************************************************************************/
    //Dbg.d(theStepRef)



    /**************************************************************************/
    /* Get the reference string into canonical form.  The input may contain
       commas or semicolons as collection separators, and since the parsing
       processing is set up to handle either, it's convenient here to convert
       them all to just one form. */

    val stepRef = theStepRef.replace(",", ";")
                            .replace("--", "-")
                            .replace("–", "-")
                            .replace(" +", "")
                            .replace("•", "") // \u2022 -- Arabic zero.
                            .replace("٠", "") // \u0660 -- Bullet point, used in some places instead of Arabic zero.
                            .replace("([1-9A-Za-z][A-Za-z][A-Za-z]\\.)".toRegex()) { it.value.replace(".", " ") }
                            .replace("(?i)title".toRegex(), "title")
                            .replace("(?i):T$".toRegex(), "")// We have things like 53:T as the alternative reference on some Psalm rows.  I change these back to be chapter references.


    /**************************************************************************/
    fun processCollectionElement (elt: String) = elt.split("-").joinToString("-"){ usxify1(it) }
    return stepRef.split(";").joinToString(";"){ processCollectionElement(it) }
  }


  /****************************************************************************/
  /* The reversification data has its own view of how references should be
     represented, and to save having to include specialised code to cater for
     these, it's convenient to convert to USX format up-front. */

  private fun usxify1 (theStepRef: String): String
  {
    /**************************************************************************/
    /* Replace the full stop after the book name with a space. */

    var stepRef = theStepRef
    if (stepRef.matches("...\\..*".toRegex()))
      stepRef = stepRef.substring(0, 3) + " " + stepRef.substring(4)



    /**************************************************************************/
    /* I _think_ we can forget subverse zero.  Otherwise, if we have numeric
       subverses, change them to alphabetic. */

    if (stepRef.endsWith(".0"))
      stepRef = stepRef.substring(0, stepRef.length - 2)
    else if (stepRef.matches(".*\\.\\d+$".toRegex()))
    {
      val ix = stepRef.lastIndexOf(".")
      val subverseNo = Integer.parseInt(stepRef.substring(ix + 1))
      stepRef = stepRef.substring(0, ix) + convertNumberToRepeatingString(subverseNo, 'a', 'z')
    }



    /**************************************************************************/
    return stepRef
  }





  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                      Private -- Ancient versions                       **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  /* You get one of these per tradition in the AncientVersions information. */

  internal class AncientVersionsTradition (theContent: String)
  {
    /**************************************************************************/
    override fun toString (): String
    {
      /************************************************************************/
      /* This first block deals with the main elements associated with a given
         tradition.  For example, the bit after the equals sign in

           Greek=12:18 / 12:17b+13:1a

         A slash is used quite commonly here to separate alternatives.  The
         above example is atypical, in that it also uses a plus-sign as a
         delimiter.

         The processing below is revoltingly messy, and even then is perhaps
         not as flexible as other aspects of the vernacular-related formatting,
         in that it assumes that a multi-element collection will always be
         shown in the same order as in the reversification data, and that it
         will be separated by delimiters in the same way as in the
         reversification data. */

      fun processMainElementRefCollection (refAsString: String): String
      {
        return if ("--" == refAsString)
          TranslatableFixedText.stringFormat(Language.Vernacular, "V_reversification_ancientVersionsNoReference")
        else
          TranslatableFixedText.stringFormat(Language.Vernacular, "V_reversification_ancientVersionsMainRefFormat", RefCollection.rd(usxifyFromStepFormat(refAsString), null,"v"))
      }

      fun processMainElementDelimiter (delim: String): String
      {
        return when (delim)
        {
          "/" -> TranslatableFixedText.stringFormat(Language.Vernacular, "V_reversification_ancientVersionsAlternativeRefsSeparator")
          "+" -> TranslatableFixedText.stringFormat(Language.Vernacular, "V_reversification_ancientVersionsJointRefsSeparator")
          else -> throw StepExceptionWithStackTraceAbandonRun("AncientVersions delimiter not handled: $delim")
        }
      }

      val delimitedMainElementsElements = m_MainElements.split("((?=^)|(?<=^))".replace("^", "[/+]").toRegex()).toMutableList() // Split with the delimiters shown in square brackets, and retain the delimiters.
      delimitedMainElementsElements.forEachIndexed { ix, content -> if ((ix and 1) == 0) delimitedMainElementsElements[ix] = processMainElementRefCollection(content) }
      delimitedMainElementsElements.forEachIndexed { ix, content -> if ((ix and 1) == 1) delimitedMainElementsElements[ix] = processMainElementDelimiter(content) }
      val mainEltsAsString = delimitedMainElementsElements.joinToString("")



      /************************************************************************/
      /* This section caters for anything within square brackets. */

      var equivalenceInformation = ""
      if (null != m_EquivalenceInformationReferenceCollection)
        equivalenceInformation = " " + TranslatableFixedText.stringFormat(m_EquivalenceInformationFormatString, m_EquivalenceInformationReferenceCollection!!)



      /************************************************************************/
      val tradition: String = TranslatableFixedText.stringFormat(Language.Vernacular, "V_reversification_language$m_Tradition")
      return TranslatableFixedText.stringFormat(Language.Vernacular, "V_reversification_ancientVersionsTraditionFormat", "tradition", tradition, "main", mainEltsAsString, "equivalenceInformation", equivalenceInformation)
    }


    /**************************************************************************/
    private var m_EquivalenceInformationReferenceCollection: RefCollection? = null
    private var m_EquivalenceInformationFormatString = ""
    private var m_MainElements = ""
    private var m_Tradition = ""


    /**************************************************************************/
    init
    {
       /************************************************************************/
       //Dbg.dCont(theContent, "/")



      /************************************************************************/
      /* Get rid of spaces, which only serve to complicate things and aren't
         of use to the processing. */

      var content = theContent.replace(" ", "")



      /************************************************************************/
      /* Split off the tradition. */

       var ix = content.indexOf("=")
       m_Tradition = content.substring(0, ix)
       content = content.substring(ix + 1)



      /************************************************************************/
      /* Remove any trailing bullet point.  Bullet points act as separators
         between traditions.  Ideally I'd have split traditions out by splitting
         at these separators, but unfortunately it looks as though in some cases
         a bullet point has been used to mark subverse zero.  (It _shouldn't_
         have been -- DIB has been using an Arabic Arabic numeral zero to mark
         subverse zero.  However, the two characters look almost identical, so
         it's easy to use the wrong one.) */

      if (content.last() == '\u2022') // Bullet point.
        content = content.substring(0, content.length - 1)



      /************************************************************************/
      /* Split off any trailing equivalence information (ie the bit in square
         brackets). */

      var equivalenceInformation: String? = null
      ix = content.indexOf("[")
      if (ix >= 0)
      {
        equivalenceInformation = content.substring(ix + 1).replace("]", "")
        content = content.substring(0, ix)
      }



      /************************************************************************/
      m_MainElements = content



      /************************************************************************/
      /* If we have equivalence information, turn it into an appropriate
         collection.  Life is made a bit easier here by the fact that we don't
         need to worry about slashes and double-dashes in the equivalence
         information, because there aren't any -- they're all pukka
         references. */

      if (null != equivalenceInformation)
      {
        when (equivalenceInformation!!.first())
        {
          '+' ->
           {
              m_EquivalenceInformationFormatString = TranslatableFixedText.lookupText(Language.Vernacular, "V_reversification_ancientVersionsEquivalencePlus")
              equivalenceInformation = equivalenceInformation!!.substring(1)
           }

           '=' ->
            {
              m_EquivalenceInformationFormatString = TranslatableFixedText.lookupText(Language.Vernacular, "V_reversification_ancientVersionsEquivalenceEquals")
              equivalenceInformation = equivalenceInformation!!.substring(1)
            }

            else ->
            {
              m_EquivalenceInformationFormatString = TranslatableFixedText.lookupText(Language.Vernacular, "V_reversification_ancientVersionsEquivalenceUndecorated")
              equivalenceInformation = equivalenceInformation!!.substring(1)
           }
        }

        m_EquivalenceInformationReferenceCollection = RefCollection.rdUsx(usxifyFromStepFormat(equivalenceInformation!!))
      }
    }
  }


  /****************************************************************************/
  /**
   * Converts the ancient version information into a vernacular string
   * containing vernacular references as far as this is possible.
   *
   * @return Ancient version information.
   */

   private fun ancientVersionsToString (traditions: List<AncientVersionsTradition>): String
   {
    val resElements: MutableList<String> = ArrayList()
    traditions.forEach { x -> resElements.add(x.toString()) }
    if (resElements.isEmpty()) return ""

    var res = resElements.joinToString(TranslatableFixedText.stringFormat(Language.Vernacular, "V_reversification_ancientVersionsTraditionSeparator"))
    res = TranslatableFixedText.stringFormat(Language.Vernacular, "V_reversification_ancientVersions", res)
    return res
  }


  /****************************************************************************/
  /* Converts the raw AncientVersion information into string format.

     Ancient version information looks like ...

       ( Hebrew=1:1 | Greek=3:16 | ... )   ['|' = bullet point]

     The references are complicated ...

     * They may be a simple reference, a reference range, or a collection.
       All of these are in STEP format with alphabetic subverses.

     * Or they may be a list of alternatives, separated by ' / ', each
       element itself being a reference, a range or a collection.

     * Or they may consist of --, indicating that there _is_ no reference.

     * And they may contain additional information in square brackets --
       information which may itself start with an equals sign or a plus sign
       (or with neither), the significance which I am currently unaware of.

     * The processing here splits these various bits out into
       AncientVersionsChunks, one per tradition.
   */

  private fun setAncientVersions (theText: String?): String
  {
    /**************************************************************************/
    //Dbg.dCont(theText ?: "", "(Greek=1:14 / 1:14a)")



    /**************************************************************************/
    if (theText.isNullOrEmpty()) return ""



    /**************************************************************************/
    val traditions: MutableList<AncientVersionsTradition> = ArrayList()



    /**************************************************************************/
    var text = theText.substring(0, theText.length - 1).substring(1) // Get rid of the enclosing parens.



    /**************************************************************************/
    /* Some entries have things with equals signs in square brackets to
       indicate that the reference list is in some manner similar to another
       alternative.  This would get in the way of the processing below, so
       temporarily I replace the equals sign. */

    text = text.replace("[=", "[\u0001")



    /**************************************************************************/
    val languageTraditions = listOf(*text.split("(?=\\b(Hebrew=|Latin=|Greek=))".toRegex()).toTypedArray())
    languageTraditions.subList(1, languageTraditions.size).forEach { traditions.add(AncientVersionsTradition(it)) }
    return ancientVersionsToString(traditions)
  }





  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                        Private -- debug support                        **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  /* stepDbgReversificationAnticipatedSourceType, if defined at all, should
     have one of the values English, Hebrew, Latin or Greek.

     The processing then expects rows whose SourceType contains the relevant
     string (case-insensitive) to be selected for processing, while others
     are not, and will output messages to that effect.  This isn't _quite_
     right (some rows are for specific variants of these like Latin2), but
     it will at least give us something at least vaguely useful for
     checking.
  */

  private val m_AnticipatedSourceType : String? by lazy { ConfigData["stepDbgReversificationAnticipatedSourceType"]?.lowercase() }


  /****************************************************************************/
  private class DebugData
  {
    var m_RowsAccepted: MutableList<ReversificationDataRow> = ArrayList() // All of the rows accepted.
    var m_RowsAcceptedButShouldNotHaveBeen: MutableList<ReversificationDataRow> = ArrayList()
    var m_RowsRejectedButShouldNotHaveBeen: MutableList<ReversificationDataRow> = ArrayList()
  }

  private val  m_DebugData = DebugData()


  /****************************************************************************/
  /* Hasn't been used recently.  At one stage I thought it useful to check how
     the selected rows stacked up against the rows we might have expected for
     a text which we knew a priori should probably follow, say, the Latin
     versification scheme.

     This runs only if we have recorded our anticipated source time; and given
     that it hasn't run for a long time, it may be that it no longer works, for
     all I know. */

  private fun debugOutputDebugData ()
  {
    if (null == m_AnticipatedSourceType) return
    m_DebugData.m_RowsAcceptedButShouldNotHaveBeen.forEach { x -> Logger.info("Reversification row accepted but perhaps should not have been: $x") }
    m_DebugData.m_RowsRejectedButShouldNotHaveBeen.forEach { x -> Logger.info("Reversification row rejected but perhaps should not have been: $x") }
    m_DebugData.m_RowsAccepted.forEach { x -> Logger.info("Reversification row accepted as anticipated: $x") }
  }


  /****************************************************************************/
  /* For debugging -- records details of which rows were accepted and
     rejected. */

  private fun debugRecordReversificationRowAccepted (dataRow: ReversificationDataRow)
  {
    /**************************************************************************/
    /* This flavour of debugging is relevant only where we are anticipating
       the text will conform reasonably closely to one of the common
       versification schemes like Latin, and have indicated as much. */

    if (null == m_AnticipatedSourceType) return



    /**************************************************************************/
    /* Ignore lines where the source ref relates to a book we don't have. */

   if (!m_DataCollection.getBibleStructure().bookExists(dataRow.sourceRef.getB())) return



   /**************************************************************************/
    val sourceType = dataRow["SourceType"].lowercase()
    val containsAnticipatedSource = sourceType.contains(m_AnticipatedSourceType!!)
    m_DebugData.m_RowsAccepted.add(dataRow)
    if (!containsAnticipatedSource)
      m_DebugData.m_RowsAcceptedButShouldNotHaveBeen.add(dataRow)
  }


  /****************************************************************************/
  /* For debugging -- records details of which rows were accepted and
     rejected. */

  private fun debugRecordReversificationRowRejected (dataRow: ReversificationDataRow)
  {
    /**************************************************************************/
    /* This flavour of debugging is relevant only where we are anticipating
       the text will conform reasonably closely to one of the common
       versification schemes like Latin, and have indicated as much. */

    if (null == m_AnticipatedSourceType) return



    /**************************************************************************/
    /* Ignore lines where the source ref relates to a book we don't have. */

   if (!m_DataCollection.getBibleStructure().bookExists(dataRow.sourceRef.getB())) return



   /**************************************************************************/
    val sourceType = dataRow["SourceType"].lowercase()
    val containsAnticipatedSource = sourceType.contains(m_AnticipatedSourceType!!)
    if (containsAnticipatedSource && Dbg.wantToProcessBook(dataRow.sourceRef.getB()))
      m_DebugData.m_RowsRejectedButShouldNotHaveBeen.add(dataRow)
  }





  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                          Significant classes                           **/
  /**                             CalloutDetails                             **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                                 Data                                   **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  private lateinit var m_RuleEvaluator: PA_ReversificationRuleEvaluator
  private val m_SelectedRows: MutableList<ReversificationDataRow> = ArrayList(10000)
} // PA_ReversificationHandler





/******************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                           Significant classes                            **/
/**                          ReversificationDataRow                          **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/* Data parsed out of the rather complicated NoteMarker field of the
   reversification data. */

class CalloutDetails
{
  var standardVerse: Ref? = null
  var standardVerseIsCanonicalTitle = false
  var alternativeRefCollection: RefCollection? = null
  var alternativeRefCollectionHasPrefixPlusSign: Boolean = false
  var alternativeRefCollectionHasEmbeddedPlusSign: Boolean = false
  var sourceVerseCollection: RefCollection? = null
}





/******************************************************************************/
/* A single row of the reversification data. */

class ReversificationDataRow (rowNo: Int)
{
  lateinit var action: String
           var ancientVersions = ""
  lateinit var fields: MutableList<String>
  lateinit var calloutDetails: CalloutDetails
           var footnoteLevel = '?'
           var isMove = false
           val rowNumber = rowNo // Publicly accessible only for debugging.
           var sourceIsPsalmTitle = false
  lateinit var sourceRef: Ref
           var sourceRefAsRefKey = 0L
  lateinit var standardRef: Ref
           var standardRefAsRefKey = 0L

  companion object {
    private val m_Headers: MutableMap<String, Int>  = TreeMap(String.CASE_INSENSITIVE_ORDER) // Headers of reversification data file.
    fun headersInitialised () = m_Headers.isNotEmpty()
    fun setHeader (name: String, ix: Int) { m_Headers[name] = ix }
  }



  /****************************************************************************/
  fun getField (key: String): String { val ix = m_Headers[key]!!; return if (ix < fields.size) fields[ix] else "" }
  fun setField (key: String, value: String) { val ix = m_Headers[key]!!; fields[ix] = value }


  /****************************************************************************/
  override fun toString (): String
  {
    return "Row: " + rowNumber.toString() + " " +
      getField("SourceType") + " " +
      getField("SourceRef") + " " +
      getField("StandardRef") + " " +
      getField("Action") + " " +
      getField("NoteMarker")
  }
} // class ReversificationDataRow

operator fun ReversificationDataRow.get (fieldName: String): String { return this.getField(fieldName) }
operator fun ReversificationDataRow.set (fieldName: String, value: String) { this.setField(fieldName, value) }













/******************************************************************************/
/* Code from the most recent previous version.   The first portion -- headed
   'Data aggregation' -- contains code needed to pick up Moves and to
   accumulate them into collections such that the collection can be moved en
   masse, rather than moving verses one at a time.  Something along these lines
   will be needed if we ever decide to reinstate conversion-time
   restructuring. */

//  /****************************************************************************/
//  /****************************************************************************/
//  /**                                                                        **/
//  /**                           Data aggregation                             **/
//  /**                                                                        **/
//  /****************************************************************************/
//  /****************************************************************************/
//
//  /****************************************************************************/
//  private val m_SelectedRows: MutableList<ReversificationDataRow> = ArrayList(10000)
//
//  private val m_MoveGroups: MutableList<ReversificationMoveGroup> = ArrayList()
//
//  private lateinit var m_AllBooks: List<String>
//  private lateinit var m_SourceBooks: List<String>
//  private lateinit var m_StandardBooks: List<String>
//
//  private lateinit var m_AllBooksInvolvedInMoveActions: List<String>
//  private lateinit var m_SourceBooksInvolvedInMoveActions: List<String>
//  private lateinit var m_StandardBooksInvolvedInMoveActions: List<String>
//
//
//  /****************************************************************************/
//  /* Carries out the various forms of data aggregation required by callers. */
//
//  private fun aggregateData ()
//  {
//    extractIfAbsentAndIfEmptyRows(AnticipatedIfAbsentDetails.getMap(), "ifabsent")
//    extractIfAbsentAndIfEmptyRows(AnticipatedIfEmptyDetails.getMap(), "ifempty")
//
//    aggregateBooks()
//    aggregateBooksInvolvedInMoveActions()
//
//    if (PROBABLY_NOT_WORKING_PA_ConversionTimeReversification().isRunnable())
//    {
//      aggregateMoveGroups()
//      markSpecialistMoves()
//    }
//
//    recordBookMappings()
//  }
//
//
//  /****************************************************************************/
//  /* Generates lists containing:
//
//     a) All books mentioned in the selected reversification rows.
//     b) All source books.
//     c) All standard books.
//  */
//
//  private fun aggregateBooks ()
//  {
//    val allBooks:     MutableSet<Int> = HashSet()
//    val bookMappings: MutableSet<String> = HashSet()
//    val sourceBooks:  MutableSet<Int> = HashSet()
//    val targetBooks:  MutableSet<Int> = HashSet()
//
//    m_SelectedRows.forEach {
//      allBooks.add(it.sourceRef.getB())
//      allBooks.add(it.standardRef.getB())
//      sourceBooks.add(it.sourceRef.getB())
//      targetBooks.add(it.standardRef.getB())
//      bookMappings.add(BibleBookNamesUsx.numberToAbbreviatedName(it.sourceRef.getB()) + "." + BibleBookNamesUsx.numberToAbbreviatedName(it.standardRef.getB()))
//    }
//
//    m_AllBooks      = allBooks   .sorted().map { BibleBookNamesUsx.numberToAbbreviatedName(it) }
//    m_SourceBooks   = sourceBooks.sorted().map { BibleBookNamesUsx.numberToAbbreviatedName(it) }
//    m_StandardBooks = targetBooks.sorted().map { BibleBookNamesUsx.numberToAbbreviatedName(it) }
//  }
//
//
//  /****************************************************************************/
//  /* Generates lists containing:
//
//     a) All books involved in Move actions.
//     b) All source books.
//     c) All standard books.
//  */
//
//  private fun aggregateBooksInvolvedInMoveActions ()
//  {
//    val allBooks:    MutableSet<Int> = HashSet()
//    val sourceBooks: MutableSet<Int> = HashSet()
//    val targetBooks: MutableSet<Int> = HashSet()
//
//    m_SelectedRows.filter { 0 != it.processingFlags.and(C_Move) }
//      .forEach { allBooks.add(it.sourceRef.getB()); allBooks.add(it.standardRef.getB()); sourceBooks.add(it.sourceRef.getB()); targetBooks.add(it.standardRef.getB()) }
//
//    m_AllBooksInvolvedInMoveActions      = allBooks   .sorted().map { BibleBookNamesUsx.numberToAbbreviatedName(it) }
//    m_SourceBooksInvolvedInMoveActions   = sourceBooks.sorted().map { BibleBookNamesUsx.numberToAbbreviatedName(it) }
//    m_StandardBooksInvolvedInMoveActions = targetBooks.sorted().map { BibleBookNamesUsx.numberToAbbreviatedName(it) }
//  }
//
//
//  /****************************************************************************/
//  /* Records footnote details for IfAbsent and IfEmpty rows and then removes
//     these rows from the ones to be processed.  Note that it doesn't matter
//     whether I choose sourceRef or standardRef for key purposes, because they
//     are the same.  And nor does it matter whether I choose the reversification
//     footnote or the versification one, because again they are the same. */
//
//  private fun extractIfAbsentAndIfEmptyRows (map: MutableMap<RefKey, String>, action: String)
//  {
//    m_SelectedRows.filter { action == it.action }. forEach { map[it.sourceRefAsRefKey] = getFootnoteVersification(it) }
//    m_SelectedRows.removeIf { action == it.action }
//  }
//
//
//  /****************************************************************************/
//  /* Generates a set containing source/standard pairs detailing which source
//     books map to which standard books. */
//
//  private fun recordBookMappings ()
//  {
//    fun addMapping (row: ReversificationDataRow)
//    {
//      val sourceBook   = BibleBookNamesUsx.numberToAbbreviatedName(row.sourceRef  .getB())
//      val standardBook = BibleBookNamesUsx.numberToAbbreviatedName(row.standardRef.getB())
//      m_BookMappings.add("$sourceBook.$standardBook")
//    }
//
//    m_SelectedRows.forEach { addMapping(it) }
//  }
//
//
//  private lateinit var m_AllBooks: List<String>
//  private lateinit var m_SourceBooks: List<String>
//  private lateinit var m_StandardBooks: List<String>//
//
//
//
//
//


//  /****************************************************************************/
//  /* This is revolting; I can only assume that the need for it became apparent
//     late in the day, when it would have been too difficult to rejig the
//     reversification data to handle it properly.
//
//     Lots of rows are marked 'AllBibles' in the SourceType field, and most of
//     these are marked KeepVerse.  Normally KeepVerse retains an existing verse
//     and complains if the verse does not already exist.
//
//     However, on AllBibles rows, KeepVerse is allowed to create verses if they
//     don't already exist -- except that in a further twist, it has to issue a
//     warning in some cases (but not all) if it has to create the verse.
//
//     And just to make life thoroughly awful, the way I am required to
//     distinguish these cases has to be based upon the contents of the FootnoteA
//     column -- certain things there imply that a warning is needed, while others
//     do not.  (The problem being here that this field is free-form text, so
//     sooner or later it is going to change, sure as eggs is eggs, and I shan't
//     realise that's an issue.) */
//
//  private val m_NoteAOptionsText = listOf("At the end of this verse some manuscripts add information such as where this letter was written",
//                                          "In some Bibles this verse is followed by the contents of Man.1 (Prayer of Manasseh)",
//                                          "In some Bibles this verse starts on a different word")
//
//  private fun getAllBiblesComplaintFlag (row: ReversificationDataRow): Int
//  {
//    val noteA = getField("Reversification Note", row)
//    return if (m_NoteAOptionsText.contains(noteA)) C_ComplainIfStandardRefDidNotExist else 0
//  }
