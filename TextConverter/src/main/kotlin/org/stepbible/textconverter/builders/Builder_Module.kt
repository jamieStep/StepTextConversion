package org.stepbible.textconverter.builders

import org.stepbible.textconverter.nonapplicationspecificutils.commandlineprocessor.CommandLineProcessor
import org.stepbible.textconverter.nonapplicationspecificutils.configdata.ConfigData
import org.stepbible.textconverter.nonapplicationspecificutils.configdata.FileLocations
import org.stepbible.textconverter.nonapplicationspecificutils.configdata.TranslatableFixedText
import org.stepbible.textconverter.nonapplicationspecificutils.debug.Logger
import org.stepbible.textconverter.nonapplicationspecificutils.miscellaneous.StepFileUtils
import org.stepbible.textconverter.nonapplicationspecificutils.miscellaneous.Zip
import org.stepbible.textconverter.nonapplicationspecificutils.shared.FeatureIdentifier
import org.stepbible.textconverter.applicationspecificutils.*
import org.stepbible.textconverter.nonapplicationspecificutils.debug.Rpt
import org.stepbible.textconverter.osisonly.Osis_AudienceAndCopyrightSpecificProcessingHandler
import java.io.File
import java.nio.file.Paths
import java.util.ArrayList


/******************************************************************************/
/**
  * Arranges to convert the OSIS generated by [Builder_InternalOsis] into a
  * module.
  *
  * @author ARA "Jamie" Jamieson
  */

object Builder_Module: Builder()
{
  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                                Public                                  **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  override fun banner () = "Creating Sword module."


  /****************************************************************************/
  override fun commandLineOptions () = listOf(
    CommandLineProcessor.CommandLineOption("manualOsis2mod", 0, "Run osis2mod manually (useful where osis2mod fails to complete under control of the converter).", null, "n", false),
    CommandLineProcessor.CommandLineOption("stepUpdateReason", 1, "A reason for creating this version of the module (required only if runType is Release and the release arises because of changes to the converter as opposed to a new release from the text suppliers).", null, null, false)
  )


  /****************************************************************************/
  override fun doIt ()
  {
    /**************************************************************************/
    Builder_InternalOsis.process()
    Rpt.report(0, banner())



    /**************************************************************************/
    if (!ConfigData.getAsBoolean("stepEncrypted", "no")) Logger.warning("********** NOT ENCRYPTED **********")
    StepFileUtils.createFolderStructure(FileLocations.getInternalSwordFolderPath())
    PackageContentHandler.processPreOsis2mod()
    Osis_AudienceAndCopyrightSpecificProcessingHandler.invokeOsis2mod()



    /**************************************************************************/
    /* Now would be a good time to abandon stuff if necessary, because after
       this we start updating history etc, and if that happens and there have,
       in fact, been errors, we'd need to work out how to roll back the history,
       which is a pain. */

    if (!checkOsis2ModLog())
      Logger.error("osis2mod has not reported success.")
    Logger.announceAll(true)



    /**************************************************************************/
    PackageContentHandler.processPostOsis2mod()
    getFileSizeIndicator()
    VersionAndHistoryHandler.appendHistoryLinesForAllAudiencesToStepConfigFile()
    createModuleZip()
  }





  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                                Private                                 **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  /* Checks the content of the OSIS log file to make sure it contains the word
     "SUCCESS", or to give an indication of just how bad things are. */

  private fun checkOsis2ModLog(): Boolean
  {
    val file = File(FileLocations.getOsisToModLogFilePath())
    if (!file.exists()) return false

    var errors = 0
    var fatals = 0
    var hadSuccess = false
    var info = 0
    var warnings = 0

    FileLocations.getInputStream(file.toString())!!.bufferedReader().readLines().forEach {
      if (it.startsWith("You are running osis2mod"))
        ConfigData["stepOsis2ModVersion"] = Regex("Rev: (\\S+)").find(it)!!.groups[1]!!.value

      else if (it.startsWith("WARNING(PARSE): SWORD does not search numeric entities"))
        return@forEach  // osis2mod doesn't like things like &#9999;, but apparently we need them and they do work.  @forEach continues with the next item.

      else if (it.startsWith("SUCCESS"))
      {
        Logger.info("osis2mod reports '$it'.")
        hadSuccess = true
      }
      else if (it.contains("FATAL"))
      {
        ++fatals
        Logger.error("osis2mod reports '$it'.")
      }
      else if (it.contains("ERROR"))
      {
        ++errors
        Logger.warning("Treated as a warning because osis2mod often overreacts: osis2mod reports '$it'.")
      }
      else if (it.contains("WARNING"))
      {
        ++warnings
        Logger.warning("osis2mod reports '$it.'")
      }
      else if (it.contains("INFO("))
      {
        ++info
        Logger.info("osis2mod reports '$it.'")
      }
    } // forEach

    if (fatals > 0)
      System.err.println("CAUTION: osis2mod.exe reports $fatals fatal error(s).  Please check the OSIS log file to see if the conversion to Sword format has worked.")
    else if (errors > 0)
      System.err.println("CAUTION: osis2mod.exe reports $errors error(s).  These have been treated here as non-fatal, because often they do not seem to reflect an actual problem, but please check the OSIS log file to see if the conversion to Sword format has worked.")
    else if (warnings > 0)
      System.err.println("CAUTION: osis2mod.exe reports $warnings warning(s).  Please check the OSIS log file to see if the conversion to Sword format has worked.")
    else if (!hadSuccess)
      System.err.println("CAUTION: osis2mod.exe has not reported success (return code was ${ConfigData["stepOsis2modReturnCode"]!!}.  Please check the OSIS log file to see if the conversion to Sword format has worked.")

    return hadSuccess
  }


  /****************************************************************************/
  /* This is the _module_ zip, not the repository zip. */

  private fun createModuleZip()
  {
    val zipPath: String = FileLocations.getSwordZipFilePath()
    val inputs = mutableListOf(FileLocations.getSwordConfigFolderPath(), FileLocations.getSwordTextFolderPath())
    if (StepFileUtils.fileOrFolderExists(FileLocations.getEncryptionAndBespokeOsisToModDataRootFolder())) inputs.add(FileLocations.getEncryptionAndBespokeOsisToModDataRootFolder())
    Zip.createZipFile(zipPath, 9, FileLocations.getInternalSwordFolderPath(), inputs)
  }


  /****************************************************************************/
  /* The Sword config file is supposed to give an indication of the module
     size (or at least, some size or other, and I'm assuming it's the module
     size). */

  private fun getFileSizeIndicator()
  {
    var size = File(Paths.get(FileLocations.getSwordTextFolderPath()).toString()).walkTopDown().filter { it.isFile }.map { it.length() }.sum()
    size = ((size + 500) / 1000) * 1000 // Round to nearest 1000.
    ConfigData.put("stepModuleSize", size.toString(), true)
  }
}





/******************************************************************************/
object PackageContentHandler
{
  /****************************************************************************/
  fun processPreOsis2mod () = doIt(m_DataPreOsis2mod)
  fun processPostOsis2mod () = doIt(m_DataPostOsis2mod)


  /****************************************************************************/
  data class ProcessingDetails (val processor: ((String) -> Unit)?, val filePath: String)



  /****************************************************************************/
  private val m_DataPreOsis2mod = listOf(
    ProcessingDetails(null,            FileLocations.getOsis2ModSupportFilePath()),
    ProcessingDetails(null,            FileLocations.getSwordConfigFolderPath()),
    ProcessingDetails(null,            Paths.get(FileLocations.getSwordTextFolderPath(), "dummyFile.txt").toString()),
  )


  /****************************************************************************/
  private val m_DataPostOsis2mod = listOf(
    ProcessingDetails(null,                          FileLocations.getSwordZipFilePath()),
    ProcessingDetails(::featuresSummaryBibleStructureHandler, FileLocations.getTextFeaturesFilePath()),
    ProcessingDetails(::featuresSummaryRunParametersHandler,  FileLocations.getRunFeaturesFilePath()),
    ProcessingDetails(::osisSaver,                            FileLocations.makeInputOsisFilePath()),
    ProcessingDetails(::swordConfigFileHandler,               FileLocations.getSwordConfigFilePath()),
 )


  /****************************************************************************/
  private fun doIt (items: List<ProcessingDetails>)
  {
    items.forEach{
      StepFileUtils.createFolderStructure(StepFileUtils.getParentFolderName(it.filePath))
      it.processor?.let { it1 -> it1(it.filePath) }
    }
  }


  /****************************************************************************/
  private fun featuresSummaryBibleStructureHandler (filePath: String) = IssueAndInformationRecorder.processFeaturesSummaryBibleDetails(filePath, InternalOsisDataCollection)
  private fun featuresSummaryRunParametersHandler (filePath: String) = IssueAndInformationRecorder.processFeaturesSummaryRunDetails(filePath)


  /****************************************************************************/
  /* Originally I left saving the external OSIS to this point so as not to
     have it lying around if the processing failed.  However, doing that
     entails soaking up an awful lot of memory for very little purpose.
     Instead, therefore, I actually save the OSIS at the earliest possible
     opportunity, but under a discouraging name, and then rename it here. */

  private fun osisSaver (dummy: String)
  {
    if ("osis" == ConfigData["stepOriginData"]!!) return // Nothing to do if this run started from OSIS, because that _is_ the external OSIS.
    StepFileUtils.renameFile(Paths.get(FileLocations.getInputOsisFolderPath(), ConfigData["stepModuleName"]!! + ".xml").toString(),
                             Paths.get(FileLocations.getInputOsisFolderPath(), "DONT_USE_ME.xml").toString())
  }


  /****************************************************************************/
  /* Generates the Sword config file.  See https://crosswire.org/wiki/DevTools:conf_Files
     for more information. */

  private fun swordConfigFileHandler (filePath: String)
  {
    /**************************************************************************/
//    Dbg.d("stepModuleCreationDate=" + ConfigData["stepModuleCreationDate"])
//    Dbg.d("stepTextIdSuppliedBySourceRepositoryOrOwnerOrganisation=" + ConfigData["stepTextIdSuppliedBySourceRepositoryOrOwnerOrganisation"])
//    Dbg.d("stepModuleName=" + ConfigData["stepModuleName"])
//    Dbg.d("stepTextVersionSuppliedBySourceRepositoryOrOwnerOrganisation=" + ConfigData["stepTextVersionSuppliedBySourceRepositoryOrOwnerOrganisation"])
//    Dbg.d("stepBibleNameInEnglish=" + ConfigData["stepBibleNameEnglish"])
//    Dbg.d("stepOwnerOrganisation=" + ConfigData["stepTextOwnerOrganisationFullName"])
//    Dbg.d("stepRepository=" + ConfigData["stepDisambiguatorForId"])
//    Dbg.d("LicenceId=" + ConfigData["stepLicenceId"])
//    Dbg.d("stepLicenceExpiryDate=" + ConfigData["stepLicenceExpiryDate"])
//    Dbg.d("stepSoftwareVersionRequired=" + ConfigData["stepSoftwareVersionRequired"])
//    Dbg.d("stepOriginData=" + ConfigData["stepOriginData"])
//    Dbg.d("stepTarget=" + ConfigData["stepTargetAudience"])



    /**************************************************************************/
    VersionAndHistoryHandler.process()
    swordConfigFileHandler_addCalculatedValuesToMetadata()



    /**************************************************************************/
    val configFile = File(filePath)
    val lines = FileLocations.getInputStream(FileLocations.getSwordTemplateConfigFilePath())!!.bufferedReader().readLines()
    val writer = configFile.bufferedWriter()



    /**************************************************************************/
    for (theLine in lines)
    {
      var line = theLine.trim()

      if ("\$includeCopyAsIsLines".equals(line, ignoreCase = true))
      {
        ConfigData.getCopyAsIsLines().forEach { writer.write(it); writer.write("\n")}
        continue
      }

      if ("\$includeChangeHistory".equals(line, ignoreCase = true))
      {
        VersionAndHistoryHandler.getHistoryLinesForThisAudience().forEach { writer.write(it); writer.write("\n") }
        continue
      }

      if (line.startsWith("#!")) continue // Internal comment only.
      line = line.split("#!")[0].trim() // Remove any trailing comment.
      writer.write(ConfigData.expandReferences(line, false)!!)
      writer.write("\n")
    }


    /**************************************************************************/
    writer.close()
  }


  /****************************************************************************/
  private fun swordConfigFileHandler_addCalculatedValuesToMetadata ()
  {
    /**************************************************************************/
    var stepInfo = """¬<hr/>
Sword module ${ConfigData["stepModuleName"]!!} Rev ${ConfigData["stepTextRevision"]!!} created by the STEPBible project ${ConfigData["stepModuleCreationDate"]!!} (${ConfigData["stepTextVersionSuppliedBySourceRepositoryOrOwnerOrganisation"] ?: ""}).
¬${ConfigData["stepThanks"]!!}
XXX_AddedValue_XXX
"""

    stepInfo = stepInfo.replace("-", "&nbsp;")
      .replace("\n", "NEWLINE")
      .replace("^¬*(&nbsp;)*\\s*\\u0001".toRegex(), "") // Get rid of entirely 'blank' lines.



    /**************************************************************************/
    val changesAppliedByStep: MutableList<String> = ArrayList()
    if (ConfigData.getAsBoolean("stepAddedValueMorphology", "No")) changesAppliedByStep.add(TranslatableFixedText.stringFormatWithLookup("V_addedValue_Morphology"))
    if (ConfigData.getAsBoolean("stepAddedValueStrongs", "No")) changesAppliedByStep.add(TranslatableFixedText.stringFormatWithLookup("V_addedValue_Strongs"))



    /**************************************************************************/
    /* If we are applying runtime reversification, then probably the only
       significant changes we make are to add footnotes.

       Some text suppliers require us to own up to making changes, so for
       safety's sake, I assume all will.  I add the text in both English and
       vernacular where available.

       (We _may_ also expand elisions and / or restructure tables, and possibly
       I ought to consider owning up to this at some point.) */

    if ("runtime" == ConfigData["stepReversificationType"])
    {
      val english    = TranslatableFixedText.stringFormatWithLookupEnglish("V_modification_FootnotesMayHaveBeenAdded")
      val vernacular = TranslatableFixedText.stringFormatWithLookup       ("V_modification_FootnotesMayHaveBeenAdded")
      changesAppliedByStep.add(vernacular)
      if (vernacular != english) changesAppliedByStep.add(english)
    }



    /**************************************************************************/
    /* If we are applying runtime reversification, then -- at least to a first
       approximation -- the versification structure is left intact.  With other
       types of reversification, this is not so: conversion-time
       reversification may change the structure fairly radically in some cases,
       and with no reversification, osis2mod may combine verses which are
       excess to the scheme it has been told to use.

       Some text suppliers require us to own up to making changes, so for
       safety's sake, I assume all will.  I add the text in both English and
       vernacular where available. */

    else // ("runtime" != ConfigData["stepReversificationType"])
    {
      val english    = TranslatableFixedText.stringFormatWithLookupEnglish("V_modification_VerseStructureMayHaveBeenModified", ConfigData["stepVersificationScheme"]!!)
      val vernacular = TranslatableFixedText.stringFormatWithLookup       ("V_modification_VerseStructureMayHaveBeenModified", ConfigData["stepVersificationScheme"]!!)
      changesAppliedByStep.add(vernacular)
      if (vernacular != english) changesAppliedByStep.add(english)
    }



    /**************************************************************************/
    var text = ""
    if (changesAppliedByStep.isNotEmpty())
    {
      text = TranslatableFixedText.stringFormatWithLookup("V_addedValue_AddedValue")
      var s =  changesAppliedByStep.joinToString(separator = "¬&nbsp;&nbsp;")
      if (s.isNotEmpty()) s= "¬&nbsp;&nbsp;$s"
      text += s
    }



    /**************************************************************************/
    val acknowledgementOfDerivedWork = ConfigData["stepWordingForDerivedWorkStipulatedByTextSupplier"]
    if (null != acknowledgementOfDerivedWork) text += "¬¬$acknowledgementOfDerivedWork"



    /**************************************************************************/
    if (null != ConfigData["stepManuallySuppliedDetailsOfChangesApplied"])
      text += (if (text.isEmpty()) "" else "¬") + ConfigData["stepManuallySuppliedDetailsOfChangesApplied"]



    /**************************************************************************/
    if (text.isNotEmpty()) text = "¬$text"
    stepInfo = stepInfo.replace("XXX_AddedValue_XXX", text)



    /**************************************************************************/
    stepInfo = stepInfo.replace("¬", "<br>")
    stepInfo = ConfigData.expandReferences(stepInfo, false)!!
    stepInfo = stepInfo.replace("NEWLINE", "")
    ConfigData.put("stepConversionInfo", stepInfo, true) // $$$$



    /**************************************************************************/
    ConfigData.put("stepDataPath", "./modules/texts/ztext/" + ConfigData["stepModuleName"] + "/", true)



    /**************************************************************************/
    var textSource = ""
    if (textSource.isEmpty()) textSource = ConfigData["stepTextRepositoryOrganisationAbbreviatedName"] ?: ""
    if (textSource.isEmpty()) textSource = ConfigData["stepTextRepositoryOrganisationFullName"] ?: ""
    if (textSource.isEmpty()) textSource = "Unknown"

    var ownerOrganisation = ConfigData.getOrError("stepTextOwnerOrganisationFullName")
    if (ownerOrganisation.isNotEmpty()) ownerOrganisation = "&nbsp;&nbsp;Owning organisation: $ownerOrganisation"

    var textDisambiguatorForId = ConfigData.getOrError("stepDisambiguatorForId")
    if (textDisambiguatorForId.isBlank() || "unknown".equals(textDisambiguatorForId, ignoreCase = true)) textDisambiguatorForId = ""

    var textId: String = ConfigData["stepTextIdSuppliedBySourceRepositoryOrOwnerOrganisation"] ?: ""
    if (textId.isBlank() || "unknown".equals(textId, ignoreCase = true)) textId = ""

    val textCombinedId =
      if (textDisambiguatorForId.isNotEmpty() && textId.isNotEmpty())
        "$textDisambiguatorForId.$textId"
      else if (textId.isNotEmpty())
        "Version $textId"
      else
        ""

    textSource = "$textSource $ownerOrganisation $textCombinedId"
    ConfigData.put("stepTextSource", textSource, true)



    /**************************************************************************/
    /* List of options taken from the documentation mentioned above.
       don't change the ordering here -- it's not entirely clear whether
       order matters, but it may do.

       Note, incidentally, that sometimes STEP displays an information button at
       the top of the screen indicating that the 'vocabulary feature' is not
       available.  This actually reflects the fact that the Strong's feature is
       not available in that Bible.

       I am not sure about the inclusion of OSISLemma below.  OSIS actually
       uses the lemma attribute of the w tag to record Strong's information,
       so I'm not clear whether we should have OSISLemma if lemma appears at
       all, even if only being used for Strong's; if it should be used if there
       are occurrences of lemma _not_ being used for Strong's; or if, in fact,
       it should be suppressed altogether.
    */

    var res = ""
    FeatureIdentifier.process(FileLocations.getInternalOsisFilePath())
    if ("ar" == ConfigData["stepLanguageCode2Char"]) res += "GlobalOptionFilter=UTF8ArabicPoints\n"
    if (FeatureIdentifier.hasLemma()) res += "GlobalOptionFilter=OSISLemma\n"
    if (FeatureIdentifier.hasMorphologicalSegmentation()) res += "GlobalOptionFilter=OSISMorphSegmentation\n"
    if (FeatureIdentifier.hasStrongs()) res += "GlobalOptionFilter=OSISStrongs\n"
    if (FeatureIdentifier.hasFootnotes()) res += "GlobalOptionFilter=OSISFootnotes\n"
    if (FeatureIdentifier.hasScriptureReferences()) res += "GlobalOptionFilter=OSISScriprefs\n" // Crosswire doc is ambiguous as to whether this should be plural or not.
    if (FeatureIdentifier.hasMorphology()) res += "GlobalOptionFilter=OSISMorph\n"
    if (FeatureIdentifier.hasNonCanonicalHeadings()) res += "GlobalOptionFilter=OSISHeadings\n"
    if (FeatureIdentifier.hasVariants()) res += "GlobalOptionFilter=OSISVariants\"\n"
    if (FeatureIdentifier.hasRedLetterWords()) res += "GlobalOptionFilter=OSISRedLetterWords\n"
    if (FeatureIdentifier.hasGlosses()) res += "GlobalOptionFilter=OSISGlosses\n"
    if (FeatureIdentifier.hasTransliteratedForms()) res += "GlobalOptionFilter=OSISXlit\n"
    if (FeatureIdentifier.hasEnumeratedWords()) res += "GlobalOptionFilter=OSISEnum\n"
    if (FeatureIdentifier.hasGlossaryLinks()) res += "GlobalOptionFilter=OSISReferenceLinks\n"
    if (FeatureIdentifier.hasStrongs()) res += "Feature=StrongsNumbers\n"
    //??? if (!FeatureIdentifier.hasMultiVerseParagraphs()) res += "Feature=NoParagraphs\n"
    ConfigData.put("stepOptions", res, true)



    /**************************************************************************/
    ConfigData["stepInputFileDigests"] = Digest.makeFileDigests()
  }


//  /****************************************************************************/
//  /* More than a little complicated.  We have a list of mappings giving the
//     source and standard verses which have been involved in reversification.
//
//     We want to convert this into a list of mappings for display to the user.
//     However, this could be a very _long_ list, and therefore perhaps unwieldy,
//     so ideally it would be good to coalesce runs of verses into a single
//     mapping.
//
//     First off, there's no absolute guarantee this is ordered by ref, so we
//     need to reorder based on the 'from' ref.
//
//     Then I need to run though the list looking for adjacent references (which
//     must be adjacent in terms of both the source and the standard reference);
//     and then finally I need to output this lot in human-readable form.
//
//     I'm not sure about this -- may really be relevant only with conversion-time
//     processing.
//  */
//
//  private fun swordConfigFileHandler_getReversificationMap (data: List<ReversificationMoveGroup>): String
//  {
//    /**************************************************************************/
//    if (data.isEmpty()) return ""
//
//
//
//    /**************************************************************************/
//    fun comparator (a: ReversificationMoveGroup, b: ReversificationMoveGroup): Int
//    {
//      var res = a.sourceRange.getLowAsRefKey().compareTo(b.sourceRange.getLowAsRefKey())
//      if (0 == res) res = a.standardRange.getLowAsRefKey().compareTo(b.standardRange.getLowAsRefKey())
//      return res
//    }
//
//    val mappings = data.sortedWith(::comparator)
//
//
//
//    /**************************************************************************/
//    val res = StringBuilder(100000)
//    res.append("<p>The changes are as follows:<table>")
//
//
//
//    /**************************************************************************/
//    /* Convert the data into an HTML table, taking into account the fact that
//       a value of zero for the verse number corresponds to a canonical title. */
//
//    mappings.forEach {
//      var sourceRef   = if (it.sourceRange  .isSingleReference()) it.sourceRange  .getLowAsRef().toString() else it.sourceRange  .toString()
//      var standardRef = if (it.standardRange.isSingleReference()) it.standardRange.getLowAsRef().toString() else it.standardRange.toString()
//      sourceRef   = sourceRef.  replace(":0", ":title")
//      standardRef = standardRef.replace(":0", ":title")
//      res.append("<tr><td>")
//      res.append(sourceRef)
//      res.append("</td><td>&#x25b6; ")
//      res.append(standardRef)
//      res.append("</td></tr>")
//    }
//
//
//
//    /**************************************************************************/
//    res.append("</table>")
//    return res.toString()
//  }
}
