package org.stepbible.textconverter.builders

import org.stepbible.textconverter.nonapplicationspecificutils.commandlineprocessor.CommandLineProcessor
import org.stepbible.textconverter.nonapplicationspecificutils.configdata.ConfigData
import org.stepbible.textconverter.nonapplicationspecificutils.configdata.FileLocations
import org.stepbible.textconverter.nonapplicationspecificutils.debug.Logger
import org.stepbible.textconverter.nonapplicationspecificutils.miscellaneous.StepFileUtils
import org.stepbible.textconverter.nonapplicationspecificutils.miscellaneous.Zip
import org.stepbible.textconverter.applicationspecificutils.*
import org.stepbible.textconverter.nonapplicationspecificutils.debug.Dbg
import org.stepbible.textconverter.nonapplicationspecificutils.debug.Rpt
import org.stepbible.textconverter.nonapplicationspecificutils.miscellaneous.ObjectInterface
import org.stepbible.textconverter.osisonly.Osis_AudienceAndCopyrightSpecificProcessingHandler
import java.io.File
import java.nio.file.Paths


/******************************************************************************/
/**
  * Arranges to convert the OSIS generated by [Builder_InternalOsis] into a
  * module.
  *
  * @author ARA "Jamie" Jamieson
  */

object Builder_Module: Builder(), ObjectInterface
{
  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                                Public                                  **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  override fun banner () = "Creating Sword module."


  /****************************************************************************/
  override fun commandLineOptions () = listOf(
    CommandLineProcessor.CommandLineOption("manualOsis2mod", 0, "Run osis2mod manually (useful where osis2mod fails to complete under control of the converter).", null, "n", false),
    CommandLineProcessor.CommandLineOption("stepUpdateReason", 1, "A reason for creating this version of the module (required only if runType is Release and the release arises because of changes to the converter as opposed to a new release from the text suppliers).", null, null, false)
  )


  /****************************************************************************/
  override fun doIt ()
  {
    /**************************************************************************/
    Builder_InternalOsis.process()
    Rpt.report(0, banner())



    /**************************************************************************/
    if (!ConfigData.getAsBoolean("stepEncrypted", "no")) Logger.warning("********** NOT ENCRYPTED **********")
    StepFileUtils.createFolderStructure(FileLocations.getInternalSwordFolderPath())
    PackageContentHandler.processPreOsis2mod()
    Osis_AudienceAndCopyrightSpecificProcessingHandler.invokeOsis2mod()



    /**************************************************************************/
    /* Now would be a good time to abandon stuff if necessary, because after
       this we start updating history etc, and if that happens and there have,
       in fact, been errors, we'd need to work out how to roll back the history,
       which is a pain. */

    if (!checkOsis2ModLog())
      Logger.error("osis2mod has not reported success.")
    Logger.announceAll(true)



    /**************************************************************************/
    PackageContentHandler.processPostOsis2mod()
    getFileSizeIndicator()
    VersionAndHistoryHandler.appendHistoryLinesForAllAudiencesToStepConfigFile()
    createModuleZip()
  }





  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                                Private                                 **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  /* Checks the content of the OSIS log file to make sure it contains the word
     "SUCCESS", or to give an indication of just how bad things are. */

  private fun checkOsis2ModLog(): Boolean
  {
    val file = File(FileLocations.getOsisToModLogFilePath())
    if (!file.exists()) return false

    var errors = 0
    var fatals = 0
    var hadSuccess = false
    var info = 0
    var warnings = 0

    FileLocations.getInputStream(file.toString()).first!!.bufferedReader().readLines().forEach {
      if (it.startsWith("You are running osis2mod"))
        ConfigData["stepOsis2ModVersion"] = Regex("Rev: (\\S+)").find(it)!!.groups[1]!!.value

      else if (it.startsWith("WARNING(PARSE): SWORD does not search numeric entities"))
        return@forEach  // osis2mod doesn't like things like &#9999;, but apparently we need them and they do work.  @forEach continues with the next item.

      else if (it.startsWith("SUCCESS"))
      {
        Logger.info("osis2mod reports '$it'.")
        hadSuccess = true
      }
      else if (it.contains("FATAL"))
      {
        ++fatals
        Logger.error("osis2mod reports '$it'.")
      }
      else if (it.contains("ERROR"))
      {
        ++errors
        Logger.warning("Treated as a warning because osis2mod often overreacts: osis2mod reports '$it'.")
      }
      else if (it.contains("WARNING"))
      {
        ++warnings
        Logger.warning("osis2mod reports '$it.'")
      }
      else if (it.contains("INFO("))
      {
        ++info
        Logger.info("osis2mod reports '$it.'")
      }
    } // forEach

    if (fatals > 0)
      System.err.println("\n\nCAUTION: osis2mod.exe reports $fatals fatal error(s).  Please check the OSIS log file to see if the conversion to Sword format has worked.")
    else if (errors > 0)
      System.err.println("\n\nCAUTION: osis2mod.exe reports $errors error(s).  These have been treated here as non-fatal, because often they do not seem to reflect an actual problem, but please check the OSIS log file to see if the conversion to Sword format has worked.")
    else if (warnings > 0)
      System.err.println("\n\nCAUTION: osis2mod.exe reports $warnings warning(s).  Please check the OSIS log file to see if the conversion to Sword format has worked.")
    else if (!hadSuccess)
      System.err.println("\n\nCAUTION: osis2mod.exe has not reported success (return code was ${ConfigData["stepOsis2modReturnCode"]!!}.  Please check the OSIS log file to see if the conversion to Sword format has worked.")

    return hadSuccess
  }


  /****************************************************************************/
  /* This is the _module_ zip, not the repository zip. */

  private fun createModuleZip()
  {
    val zipPath: String = FileLocations.getSwordZipFilePath()
    val inputs = mutableListOf(FileLocations.getSwordConfigFolderPath(), FileLocations.getSwordTextFolderPath())
    if (StepFileUtils.fileOrFolderExists(FileLocations.getEncryptionAndBespokeOsisToModDataRootFolder())) inputs.add(FileLocations.getEncryptionAndBespokeOsisToModDataRootFolder())
    Zip.createZipFile(zipPath, 9, FileLocations.getInternalSwordFolderPath(), inputs)
  }


  /****************************************************************************/
  /* The Sword config file is supposed to give an indication of the module
     size (or at least, some size or other, and I'm assuming it's the module
     size). */

  private fun getFileSizeIndicator()
  {
    var size = File(Paths.get(FileLocations.getSwordTextFolderPath()).toString()).walkTopDown().filter { it.isFile }.map { it.length() }.sum()
    size = ((size + 500) / 1000) * 1000 // Round to nearest 1000.
    ConfigData.put("stepModuleSize", size.toString(), true)
  }
}





/******************************************************************************/
object PackageContentHandler: ObjectInterface
{
  /****************************************************************************/
  fun processPreOsis2mod () = doIt(m_DataPreOsis2mod)
  fun processPostOsis2mod () = doIt(m_DataPostOsis2mod)


  /****************************************************************************/
  data class ProcessingDetails (val processor: ((String) -> Unit)?, val filePath: String)



  /****************************************************************************/
  private val m_DataPreOsis2mod = listOf(
    ProcessingDetails(null, FileLocations.getOsis2ModSupportFilePath()),
    ProcessingDetails(null, FileLocations.getSwordConfigFolderPath()),
    ProcessingDetails(null, Paths.get(FileLocations.getSwordTextFolderPath(), "dummyFile.txt").toString()),
  )


  /****************************************************************************/
  private val m_DataPostOsis2mod = listOf(
    ProcessingDetails(null,                          FileLocations.getSwordZipFilePath()),
    ProcessingDetails(::featuresSummaryBibleStructureHandler, FileLocations.getTextFeaturesFilePath()),
    ProcessingDetails(::featuresSummaryRunParametersHandler,  FileLocations.getRunFeaturesFilePath()),
    ProcessingDetails(::osisSaver,                            FileLocations.makeInputOsisFilePath()),
    ProcessingDetails(::swordConfigFileHandler,               FileLocations.getSwordConfigFilePath()),
 )


  /****************************************************************************/
  private fun doIt (items: List<ProcessingDetails>)
  {
    items.forEach{
      StepFileUtils.createFolderStructure(StepFileUtils.getParentFolderName(it.filePath))
      it.processor?.let { it1 -> it1(it.filePath) }
    }
  }


  /****************************************************************************/
  private fun featuresSummaryBibleStructureHandler (filePath: String) = IssueAndInformationRecorder.processFeaturesSummaryBibleDetails(filePath, InternalOsisDataCollection)
  private fun featuresSummaryRunParametersHandler (filePath: String) = IssueAndInformationRecorder.processFeaturesSummaryRunDetails(filePath)


  /****************************************************************************/
  /* Originally I left saving the external OSIS to this point so as not to
     have it lying around if the processing failed.  However, doing that
     entails soaking up an awful lot of memory for very little purpose.
     Instead, therefore, I actually save the OSIS at the earliest possible
     opportunity, but under a discouraging name, and then rename it here. */

  private fun osisSaver (dummy: String)
  {
    if ("osis" == ConfigData["stepOriginData"]!!) return // Nothing to do if this run started from OSIS, because that _is_ the external OSIS.
    StepFileUtils.renameFile(Paths.get(FileLocations.getInputOsisFolderPath(), ConfigData["stepModuleName"]!! + ".xml").toString(),
                             Paths.get(FileLocations.getInputOsisFolderPath(), "DONT_USE_ME.xml").toString())
  }


  /****************************************************************************/
  /* Generates the Sword config file.  See https://crosswire.org/wiki/DevTools:conf_Files
     for more information. */

  private fun swordConfigFileHandler (filePath: String)
  {
    /**************************************************************************/
    VersionAndHistoryHandler.process()



    /**************************************************************************/
    val configFile = File(filePath)
    val lines = FileLocations.getInputStream(FileLocations.getSwordTemplateConfigFilePath()).first!!.bufferedReader().readLines()
    val writer = configFile.bufferedWriter()



    /**************************************************************************/
    for (theLine in lines)
    {
      var line = theLine.trim()

      if ("\$includeCopyAsIsLines".equals(line, ignoreCase = true))
      {
        ConfigData.getCopyAsIsLines().forEach { writer.write(it); writer.write("\n")}
        continue
      }

      if ("\$includeChangeHistory".equals(line, ignoreCase = true))
      {
        VersionAndHistoryHandler.getHistoryLinesForThisAudience().forEach { writer.write(it); writer.write("\n") }
        continue
      }

      if (line.startsWith("#!")) continue // Internal comment only.
      line = line.split("#!")[0].trim() // Remove any trailing comment.
      writer.write(ConfigData.expandReferences(line, false)!!)
      writer.write("\n")
    }


    /**************************************************************************/
    writer.close()
  }
}
