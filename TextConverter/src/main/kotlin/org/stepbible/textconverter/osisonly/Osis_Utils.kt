package org.stepbible.textconverter.osisonly

import org.stepbible.textconverter.nonapplicationspecificutils.bibledetails.BibleAnatomy
import org.stepbible.textconverter.nonapplicationspecificutils.bibledetails.BibleBookNamesOsis
import org.stepbible.textconverter.nonapplicationspecificutils.configdata.ConfigData
import org.stepbible.textconverter.nonapplicationspecificutils.miscellaneous.ObjectInterface
import org.stepbible.textconverter.nonapplicationspecificutils.stepexception.StepExceptionWithStackTraceAbandonRun
import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.HashMap

/****************************************************************************/
/**
 * Common OSIS-related functionality -- creating file header etc.
 *
 * @author ARA "Jamie" Jamieson
 */

object Osis_Utils: ObjectInterface
{
  /****************************************************************************/
  /****************************************************************************/
  /**                                                                        **/
  /**                               Public                                   **/
  /**                                                                        **/
  /****************************************************************************/
  /****************************************************************************/

  /****************************************************************************/
  /**
  * Returns a string representing an OSIS file header.
  *
  * @param bookNumbers A list of the book numbers being processed.
  * @return File header.
  */

  fun fileHeader (bookNumbers: List<Int>): String
  {
    /**************************************************************************/
    val scope = makeScope(bookNumbers)



    /**************************************************************************/
    val todaysDate = SimpleDateFormat("dd-MMM-yy").format(Date())

    val standardComment = "\n\n" +
                          "<!-- ====================================================================================================\n\n\n" +
                          "     StepSummary: OSIS generated by the STEP project (www.stepbible.org) $todaysDate.\n" +
                          "     StepOriginalSourceType: ${ConfigData["stepOriginData"]!!}\n\n" +
                          "     According to the OSIS documentation, the osis tag should look like:\n\n\n" +
                          "        <osis xmlns='http://www.bibletechnologies.net/2003/OSIS/namespace'\n" +
                          "              xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'\n" +
                          "              xsi:schemaLocation='http://www.bibletechnologies.net/2003/OSIS/namespace\n" +
                          "                http://www.bibltechnolgologies.net/OSIS/osisCore.2.1.xsd\n\n" +
                          "     None of these URI's exist, and since having the line here stops the processing\n" +
                          "     from working correctly, we have opted to drop the details.\n\n\n" +
                          "     ==================================================================================================== -->\n\n\n"



    /**************************************************************************/
    /* Note: Near the bottom of this header, I have a work and a workPrefix tag
       which ostensibly are needed to support Strong's.  I have no idea whether
       this is actually the case, nor, in fact what they should look like (I
       imagine, for instance, that the work tag should contain some
       sub-elements, but the documentation gives no examples.)  So I may be
       wrong that they are needed; and if needed, I may have got them wrong
       (except that things seem to have worked ok with at least one Strong's
       text I've worked with).  And I also don't know whether they should be
       included _only_ on texts which have Strongs.  (I do have earlier
       processing which sets a flag in SharedData/FeatureIdentifier to flag
       where we have Strongs, although ideally support for that should be
       removed if it looks as though we can safely include the Strong's stuff
       come what may. */

var header =
"""
<?xml version='1.0' encoding='UTF-8'?>%%%standardComment%%%
<osis>
  <osisText osisIDWork='${'$'}moduleName' osisRefWork='${'$'}toLowerPublicationType' xml:lang='${'$'}languageCode' canonical='true'>
    <header>
      ${'$'}revisionDesc
      <work osisWork='${'$'}moduleName'>
        <title>${'$'}title</title>
        <type type='OSIS'>${'$'}publicationType</type>
        <identifier type='OSIS'>${'$'}publicationType.${'$'}languageCode.${'$'}moduleName.${'$'}yearOfText</identifier>
        <rights type='x-copyright'>${'$'}shortCopyright</rights>
        <scope>${'$'}scope</scope>
        <refSystem>${'$'}publicationType</refSystem>
      </work>
      <work osisWork='${'$'}toLowerPublicationType'>
        <type type='OSIS'>${'$'}publicationType</type>
        <refSystem>Bible</refSystem>
      </work>
      <work osisWork='strong'/> <!-- Strongs.  I'm not sure whether there's a problem including this even on texts which don't need it; and I'm not actually sure it's needed at all. -->
    </header>"""

    header = header.replace("%%%standardComment%%%", standardComment).replace("$", "\u0001")



    /**************************************************************************/
    /* Fill in details in the standard header string.  A few notes ...

       * revisionDesc: Keeps tracks of revisions.  I doubt this information will
         be available to us in any meaningful form, for which reason I have not
         attempted to do anything 'proper' with it.  This means that at present
         it would need to be supplied in the configuration information in the
         format required by the OSIS reference manual, qv.
    */

    var yearOfText = ConfigData["stepTextModifiedDate"]!!
    if (yearOfText.contains("-")) yearOfText = yearOfText.split("-")[2]

    var publicationType = if ("bible" == (ConfigData["stepTypeOfDocument"] ?: "bible").lowercase()) "zText" else "zCom"
    publicationType = if (publicationType.equals("zText", ignoreCase = true)) "Bible" else "Commentary"

    val vals: MutableMap<String, String?> = HashMap()
    vals["standardComment"] = standardComment
    vals["languageCode"] = ConfigData["stepLanguageCode3Char"]
    vals["moduleName"] = if (ConfigData.getAsBoolean("stepEvaluateSchemesOnly", "no")) "???EvaluationOnly???" else ConfigData["stepModuleName"]
    vals["publicationType"] = publicationType
    vals["revisionDesc"] = ConfigData["revisionDesc"] ?: "" // See note above.
    vals["scope"] = scope
    vals["shortCopyright"] = ConfigData["stepShortCopyright"]!!.replace("<.*?>".toRegex(), " ").replace("&copy;", "(c)")
    vals["title"] = ConfigData["stepBibleDescriptionAsItAppearsOnBiblePicker"]!!
    vals["toLowerPublicationType"] = publicationType.lowercase(Locale.getDefault())
    vals["yearOfText"] = yearOfText



    /**************************************************************************/
    if (null == vals["scope"])
    {
      vals.remove("scope")
      header = header.replace("<scope>\u0001scope</scope>".toRegex(), "")
    }



    /**************************************************************************/
    for (key in vals.keys) header = header.replace("\u0001" + key, vals[key]!!)
    if (header.contains("\u0001")) throw StepExceptionWithStackTraceAbandonRun("OSIS header: incomplete substitution.")
    header = header.replace("(?m)^[ \\t]*\\r?\\n".toRegex(), "").replace("\n\n", "\n")
    return header
  }


  /****************************************************************************/
  /**
  * Returns a string representing an OSIS file trailer.
  *
  * @return File trailer.
  */

  fun fileTrailer () = "</osisText>\n</osis>\n"


  /****************************************************************************/
  /**
  * Returns a string to be used as the 'scope' value in the file header.
  *
  * I haven't put a huge amount of effort into this: if we have the whole of the
  * OT plus the whole of the NT, I return null (even if we also have DC books).
  * Otherwise if we have the whole of either testament, I give the thing as a
  * range.  Otherwise I name every book (including DC)
  *
  * Have to say I'm really not too sure about this.  The OSIS doc seems to
  * give the impression that it's needed any time you don't have an entire
  * work, but in the context of the Bible I don't know what an entire work
  * would be anyway (ie what about DC texts?).  So I'm kinda doing something
  * here (and assuming that the whole of the OT plus the whole of the OT does
  * indeed constitute an entire work), but whether this is the right thing to
  * do -- or whether it actually matters anyway -- I have no idea.
  *
  * @param
  * @return Scope string.
  */

  private fun makeScope (bookNumbersPossiblyUnsorted: List<Int>): String?
  {
    val bookNumbers = bookNumbersPossiblyUnsorted.sorted()

    val otBooks = bookNumbers.filter { BibleAnatomy.isOt(it) }
    val ntBooks = bookNumbers.filter { BibleAnatomy.isNt(it) }
    val dcBooks = bookNumbers.filter { BibleAnatomy.isDc(it) }

    val hasOt = otBooks.isNotEmpty()
    val hasNt = ntBooks.isNotEmpty()
    val hasDc = dcBooks.isNotEmpty()

    val hasFullOt = hasOt && otBooks.size == BibleAnatomy.getNumberOfBooksInOt() && otBooks.min() == BibleAnatomy.getBookNumberForStartOfOt() && otBooks.max() == BibleAnatomy.getBookNumberForEndOfOt()
    val hasFullNt = hasNt && ntBooks.size == BibleAnatomy.getNumberOfBooksInNt() && ntBooks.min() == BibleAnatomy.getBookNumberForStartOfNt() && ntBooks.max() == BibleAnatomy.getBookNumberForEndOfNt()

    if (hasFullOt && hasFullNt) return null
    var resOt = ""; if (hasFullOt) resOt = "Gen-Mal"  else if (hasOt) resOt = otBooks.joinToString(" "){ BibleBookNamesOsis.numberToAbbreviatedName(it) }
    var resNt = ""; if (hasFullNt) resNt = "Matt-Rev" else if (hasNt) resNt = ntBooks.joinToString(" "){ BibleBookNamesOsis.numberToAbbreviatedName(it) }
    var resDc = ""; if (hasDc) resDc = dcBooks.joinToString(" "){ BibleBookNamesOsis.numberToAbbreviatedName(it) }
    var res = "$resOt $resNt $resDc"
    res = res.trim().replace("\\s+".toRegex(), " ")
    return res
  }
}