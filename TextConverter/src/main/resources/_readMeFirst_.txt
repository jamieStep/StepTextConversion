#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!
#! To save you having to dig around for the information below, if there is
#! more than one definition for a given item, the definition which takes
#! precedence is the one which is encountered
#!
#!  .----------------.  .----------------.  .----------------.  .----------------. 
#! | .--------------. || .--------------. || .--------------. || .--------------. |
#! | |   _____      | || |      __      | || |    _______   | || |  _________   | |
#! | |  |_   _|     | || |     /  \     | || |   /  ___  |  | || | |  _   _  |  | |
#! | |    | |       | || |    / /\ \    | || |  |  (__ \_|  | || | |_/ | | \_|  | |
#! | |    | |   _   | || |   / ____ \   | || |   '.___`-.   | || |     | |      | |
#! | |   _| |__/ |  | || | _/ /    \ \_ | || |  |`\____) |  | || |    _| |_     | |
#! | |  |________|  | || ||____|  |____|| || |  |_______.'  | || |   |_____|    | |
#! | |              | || |              | || |              | || |              | |
#! | '--------------' || '--------------' || '--------------' || '--------------' |
#!  '----------------'  '----------------'  '----------------'  '----------------' 
#!
#! unless any earlier definitions have been marked as 'force'.
#!
#!
#!
#!
#!
#! Configuration data -- an overview
#! =================================
#!
#! There are essentially two pieces of information you're going to need -- you
#! need to know where to find the various kinds of configuration data in case
#! you need to change them; and you need to know the syntax for specifying
#! configuration data.  I deal with the first of these first, but if you scroll
#! down far enough, you'll find the syntax details too.
#!
#! Configuration data does a number of different things.  For example:
#!
#! - It controls how the processing works and what it does.  (It does this along
#!   with command line parameters, but the command line parameters are also
#!   copied into the configuration data structure, so that everything can be
#!   accessed in a consistent manner.  If there is any conflict between the two,
#!   the command-line parameters take precedence.)
#!
#! - It records details of how scripture references are represented in the
#!   various schemes -- USX, OSIS, and whatever vernacular is currently being
#!   processed.
#!
#! - It holds definitions of things like Creative Commons licence terms etc.
#!
#! - It holds details of any simple translations between USX and OSIS tags.
#!
#! - It holds text strings in various languages -- for example, those which
#!   appear in the footnotes generated by the reversification process.
#!
#! - It holds the information needed to extract configuration data from
#!   external metadata files such as those supplied by DBL.
#!
#! All of this means that there is a _lot_ of configuration data, in order to
#! provide the degree of flexibility which we need (or which I suspect might
#! _possibly_ be needed at some point).
#!
#! The good news, though, is that to date there has been relatively little need
#! to poke around in the more obscure aspects of this.  There is a fairly small
#! subset of the configuration data which you _need_ to alter (and which,
#! actually, you would _expect_ to need to alter -- things like language codes,
#! copyright information etc); but the majority of things will not change from
#! one text to another.  Details of the things you are most likely to need to
#! change are held in the file config.conf, and you should refer to that for
#! more details.
#!
#! This present file gives an overview of the configuration data, and also
#! explains some of the principles you need to follow in setting up your own
#! configuration data.
#!
#! To make things easier to manage, you can split the data up among a number
#! of different files, so that you can put all associated items into a single
#! file.  And where appropriate (ie where the same information is going to be
#! common to a number of different texts), you can store this information
#! somewhere where all of them can get at it.  Again, this is covered below.
#!
#!
#!
#!
#!
#! The built-in files
#! ==================
#!
#! There are a number of built-in files co-located with this present file in
#! the Resources section of this JAR file.
#!
#! These provide backstop settings, both for things which I do not presently
#! anticipate will _ever_ need changing (they appear in config files purely in
#! case that assumption is wrong), and for things which may _perhaps_ need
#! overriding occasionally, but in general will not do so.
#!
#! The simplest way to approach the configuration data is probably to read
#! the remainder of the present file, which describes the basics of how
#! configuration data is represented.  Then look at config.conf.  Only if you
#! determine that you need additional information would you need to have
#! recourse to the other built-in files.
#!
#!
#!
#!
#!
#! General organisation
#! ====================
#!
#! Configuration data comes in the form of key=value pairs.
#!
#! These statements are stored in one or more files.  Because there is so
#! much configuration data, you may find it convenient to group related
#! items together, and put each group into a file of its own.  You can do
#! this in any way you see fit -- the processing does not ascribe any meaning
#! to the manner in which the statements are split up.
#!
#! You must have a file called config.conf in the Metadata folder for each
#! text.  This forms the root of the configuration collection.  You create
#! this file by copying config.conf from the Resources collection and then
#! modifying it to suit the text you are processing.  Details of what to do
#! appear within config.conf itself.
#!
#!
#! From this, it will be apparent that files may refer out to other files via
#! Include statements.  These come in two forms:
#!
#!   $include ...
#!   $includeIfExists ...
#!
#! The former always includes the content of the file represented here by '...'.
#! The latter includes the file if it exists, but does not complain if it does
#! not.
#!
#! Standard files containing typical defaults are stored in the present JAR
#! file.  To access these, you give the path as $common/... -- eg:
#!
#!  $include $common/commonForTargetSword.conf
#!
#! You may also use a path relative to the root folder of the text being
#! processed, which you give as $root/... -- eg:
#!
#!  $include $root/../japaneseTexts.conf
#!
#! ... or to the Metadata folder for the text (by using $metadata/).  Or if
#! you supply a path which is not in any of these forms, it is assumed to
#! to be located relative to the file in which the $include statement is
#! found.
#!
#! All of this may be useful where you have a number of texts all of which want
#! to use common information.  With the above example, you might set up the
#! root folder for each of a number of different Japanese Bibles below a
#! common folder, and then store the common configuration information in that
#! folder.
#!
#! As a more complicated example, you might end up with a structure
#! something like:
#!
#!                                Root
#!                                 |
#!                 +---------------+-----------------------+
#!                 |               |                       |
#!                DBL            BibleInEveryLanguage     Etc
#!                 |                      |                |
#!                 +                      +                +
#!                 |                      |                |
#!        +--------+----+            +----+---+            |
#!        |             |            |        |            |
#!      TextA       Bulgarian      TextD    TextE         Etc
#!                      |
#!                 +----+----+
#!                 |         |
#!               TextB     TextC
#!
#!
#! $include's may be nested to any depth, and the effect is as though each
#! $include was replaced by the content of the file to which it points.
#!
#! It is perfectly valid to have more than one definition for the same
#! configuration item in this expanded text.  In such cases, the
#!
#!  .----------------.  .----------------.  .----------------.  .----------------. 
#! | .--------------. || .--------------. || .--------------. || .--------------. |
#! | |   _____      | || |      __      | || |    _______   | || |  _________   | |
#! | |  |_   _|     | || |     /  \     | || |   /  ___  |  | || | |  _   _  |  | |
#! | |    | |       | || |    / /\ \    | || |  |  (__ \_|  | || | |_/ | | \_|  | |
#! | |    | |   _   | || |   / ____ \   | || |   '.___`-.   | || |     | |      | |
#! | |   _| |__/ |  | || | _/ /    \ \_ | || |  |`\____) |  | || |    _| |_     | |
#! | |  |________|  | || ||____|  |____|| || |  |_______.'  | || |   |_____|    | |
#! | |              | || |              | || |              | || |              | |
#! | '--------------' || '--------------' || '--------------' || '--------------' |
#!  '----------------'  '----------------'  '----------------'  '----------------' 
#!
#! one to be encountered takes precedence.
#!
#!
#!
#!
#!
#! Basic syntax
#! ============
#!
#! The syntax comprises a few different kinds of elements:
#!
#! - Comments.  The comment marker is #!.  Any text after this to the end
#!   of the line is ignored, along with any blanks prior to the #! on the
#!   line.  If the only remaining portion of the line is empty, the line
#!   itself is ignored.
#!
#! - Blank lines.  These are ignored.
#!
#! - Lines of the form stepTagTranslation=... eg
#!
#!     stepTagTranslation=(usx=Ͼchar:bditϿ osis=Ͼ<hi type='bold'><hi type='italic'>Ͽ)
#!
#!   set out details of what OSIS tag should be generated for a given USX tag
#!   (where the relationship is simple enough for a straightforward mapping
#!   to suffice).  There's a lot to say about this -- see the file
#!   usxToOsisTagConversionsEtc.conf for more information.
#!
#! - $include / $includeIfExists (as discussed above).
#!
#! - Lines which include the word 'external'.  These are concerned with situations
#!   where configuration information is available from external sources, such as
#!   the metadata.xml files supplied by DBL.  For details, refer to the file
#!   PerTextRepositoryOrganisation/Dbl.conf in this JAR file.
#!
#! * Definitions of the form key=value, which associate a value with the given
#!   key.  You can have any key you like, but the ones actually used by the
#!   processing are the aggregate of those found in all of the various common
#!   configuration files (ie the ones you will find in this JAR file).  There
#!   is also a variant form of this statement -- key#=value -- which is
#!   discussed below.
#!
#! In the case of the definitions, the 'value' portion may refer out to the
#! value of other definitions by including @(key).  The value associated
#! with 'key' is then substituted at this point.  This can be nested to
#! any depth -- if the value associated with @(key) itself contains
#! embedded @(...)s, then they in turn are looked up -- and so on.
#!
#! You can also give alternatives within the @(...) -- just separate them
#! with commas and optional spaces: @(myBirthday, yourBirthday).  In this
#! case, the processing works left to right until it finds a non-null value
#! (and throws an exception if all are null).  And you can give a default
#! text value if you precede it by an equals sign:
#!
#!    @(myBirthDay, yourBirthday, =01-Jan-2000)
#!
#! Note that substitutions are made at the time the data is _requested_, not
#! when the configuration data is loaded.  So if, immediately after loading
#! the configuration data, a particular key 'myName' is associated with
#! 'John', and if another key 'hi' is associated with 'My name is @(myName)',
#! querying 'hi' immediately after the data load will give 'My name is John'.
#! But if the processing then sets 'myName' to 'Mary', querying 'hi' after that
#! point will return 'My name is Mary'.
#!
#! There are also a few other points to note:
#!
#! - Spaces at the start and end of a definition are trimmed off, so that
#!   'myThing=   Some text   ' is exactly the same as 'myThing=Some text'.
#!   Spaces within the body of the definition are retained as-is, however,
#!   so that 'myThing=Some     text' defines myThing as being a string
#!   with a lot of spaces in the middle.  If you need to force spaces at
#!   the front or end of the definition to be respected, give them as
#!   '{space}'.
#!
#! - Definitions which lack a right-hand side (myThing=   or myThing#=   )
#!   associate an empty string with the key.  For the sake of clarity, you
#!   can also give the right-hand side as {empty} to achieve the same effect.
#!
#!
#!
#!
#!
#! Miscellaneous
#! =============
#!
#! * Command line parameters are written to the configuration data repository,
#!   so they can be treated like any other configuration parameter.  They are
#!   added very late in the processing, and will therefore override anything
#!   supplied from the default collections and from your config.conf.
#!
#! * There are some calculated values which can be accessed as though they
#!   were ordinary configuration parameters.  These all have 'calc' in their
#!   key names.  These can be a little difficult to use, because they
#!   become available only after the processing which generates them has
#!   run, so you have to know when it is safe to attempt to access them.
#!
#!
#!
#!
#!
#! Obtaining data from external sources
#! ====================================
#!
#! The syntax here makes special provision for obtaining data from
#! external sources.  For example, DBL always provides a file called
#! metadata.xml, and to save having to transcribe data from that
#! file into our own configuration file manually, you may prefer to
#! have processing which does the extraction automatically.
#!
#! In order for this to work, you need to add code to ConfigDataSupport.java to
#! handle the transfer. At the time of writing, only DBL is supported in this
#! way.
#!
#! In the configuration file, you have to indicate the name of the
#! external file which supplies the data.  For DBL, this would involve
#! a line like :-
#!
#!   stepExternalDataSource=dbl:metadata:$metadata/metadata.xml
#!
#! where the right-hand side gives a file path.  More information about this
#! can be found in Dbl.conf.
#!
#! You can also optionally have a similar definition to pick up licence
#! information.
#!
#!
#!
#!
#!
#! Overriding definitions
#! ======================
#!
#! With so many configuration parameters spread across so many files, it is
#! perfectly possible that you may have more than one definition for the same
#! parameter.  Indeed it is rather intended for things to work this way, because
#! it makes it possible to define defaults and then override them.
#!
#! In general, if there is more than one definition for a given parameter, the
#! on encountered _last_ wins.  There is one wrinkle, however.  If you use
#! a#=b instead of a=b, this forces a to retain that particular value come what
#! may (ie even if there are later a=x or a#=x definitions.
#!
#! This makes it possible for you to ensure that things will have the value you
#! require regardless of what may happen in the various common files you load.
#! (With very few exceptions, I never use #= in these files.)
#!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
