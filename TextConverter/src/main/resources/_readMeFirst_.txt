#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!
#! To save you having to dig around for the information below, if there is
#! more than one definition for a given item, the definition which takes
#! precedence is the one which is encountered
#!
#!  .----------------.  .----------------.  .----------------.  .----------------. 
#! | .--------------. || .--------------. || .--------------. || .--------------. |
#! | |   _____      | || |      __      | || |    _______   | || |  _________   | |
#! | |  |_   _|     | || |     /  \     | || |   /  ___  |  | || | |  _   _  |  | |
#! | |    | |       | || |    / /\ \    | || |  |  (__ \_|  | || | |_/ | | \_|  | |
#! | |    | |   _   | || |   / ____ \   | || |   '.___`-.   | || |     | |      | |
#! | |   _| |__/ |  | || | _/ /    \ \_ | || |  |`\____) |  | || |    _| |_     | |
#! | |  |________|  | || ||____|  |____|| || |  |_______.'  | || |   |_____|    | |
#! | |              | || |              | || |              | || |              | |
#! | '--------------' || '--------------' || '--------------' || '--------------' |
#!  '----------------'  '----------------'  '----------------'  '----------------' 
#!
#! unless any earlier definitions have been marked as 'force'.  With things marked
#! 'force', the _first_ definition is used.
#!
#! This will make more sense once you have read the rest of the documentation.
#!
#!
#!
#!
#!
#! Configuration data -- an overview
#! =================================
#!
#! There are essentially two pieces of information you're going to need -- you
#! need to know where to find the various kinds of configuration data in case
#! you need to change them; and you need to know the syntax for specifying
#! configuration data.  I deal with the first of these first, but if you scroll
#! down far enough, you'll find the syntax details too.
#!
#! Configuration data does a number of different things.  For example:
#!
#! - It controls how the processing works and what it does.  (It does this along
#!   with command line parameters, but the command line parameters are also
#!   copied into the configuration data structure, so that everything can be
#!   accessed in a consistent manner.  If there is any conflict between the two,
#!   the command-line parameters take precedence.)  For example, it may tell the
#!   converter not to worry too much about certain types of error.
#!
#! - It records details of how scripture references are represented in the
#!   various schemes -- USX, OSIS, and whatever vernacular is currently being
#!   processed.  So, for instance, it may say that in USX a scripture
#!   reference may look like Gen 1:2.
#!
#! - It holds definitions of things like Creative Commons licence terms etc.
#!
#! - It holds details of any simple translations between USX and OSIS tags.
#!   In other words, if you have, say, para:p in USX, what should that turn
#!   into in OSIS?
#!
#! - It holds text strings in various languages -- for example, those which
#!   appear in the footnotes generated by the reversification process.
#!   So it may say that the the phrase 'This verse is empty in this
#!   translation' should be rendered as 'Dieser Vers ist in dieser Übersetzung
#!   leer' when processing a German text.
#!
#! - It holds the information needed to extract configuration data from
#!   external metadata files such as those supplied by DBL.
#!
#! All of this means that there is a _lot_ of configuration data, in order to
#! provide the degree of flexibility which we need (or which I suspect might
#! _possibly_ be needed at some point).
#!
#! The good news, though, is that to date there has been relatively little need
#! to poke around in the more obscure aspects of this.  There is a fairly small
#! subset of the configuration data which you _need_ to alter (and which,
#! actually, you would _expect_ to need to alter -- things like language codes,
#! copyright information etc); but the majority of things will not change from
#! one text to another.  Details of the things you are most likely to need to
#! change are held in the file config.conf, and you should refer to that for
#! more details, and copy and tailor it as the basis of your own configuration.
#!
#! This present file gives an overview of the configuration data, and also
#! explains some of the principles you need to follow in setting up your own
#! configuration data.
#!
#! To make things easier to manage, you can split the data up among a number
#! of different files, so that you can put all associated items into a single
#! file.  And where appropriate (ie where the same information is going to be
#! common to a number of different texts), you can store this information
#! somewhere where all of them can get at it.  Again, this is covered below.
#!
#!
#!
#!
#!
#! The built-in files
#! ==================
#!
#! There are a number of built-in files co-located with this present file in
#! the Resources section of this JAR file.
#!
#! These provide backstop settings, both for things which I do not presently
#! anticipate will _ever_ need changing (they appear in config files purely in
#! case that assumption is wrong), and for things which may _perhaps_ need
#! overriding occasionally, but in general will not do so.
#!
#! The simplest way to approach the configuration data is probably to read
#! the remainder of the present file, which describes the basics of how
#! configuration data is represented.  Then look at config.conf.  Only if you
#! determine that you need to configure other things would you need to have
#! recourse to the other built-in files.
#!
#!
#!
#!
#!
#! General organisation
#! ====================
#!
#! Configuration data comes in the form of key=value pairs.
#!
#! These statements are stored in one or more files.  Because there is so
#! much configuration data, you may find it convenient to group related
#! items together, and put each group into a file of its own.  You can do
#! this in any way you see fit -- the processing does not ascribe any meaning
#! to the manner in which the statements are split up among files.
#!
#! You must have a file called config.conf in the Metadata folder for your
#! text.  This forms the root of the configuration collection.  You create
#! this file by copying config.conf from the Resources collection and then
#! modifying it to suit the text you are processing.  Details of what to do
#! appear within config.conf itself.  From here you can include other files
#! if you wish -- and they, in turn, may include yet other files, to any
#! reasonable depth.
#!
#! You include these other files using 'include' statements, as discussed
#! shortly.  The simplest way to think of things is to imagine each include
#! statement being replaced in situ by the content of the file to which it
#! refers, and then the entire expanded text being processed after that.
#!
#! Include statements come in two forms:
#!
#!   $include ...
#!   $includeIfExists ...
#!
#! The former always includes the content of the file represented here by '...',
#! and gives up if the file does not exist.  The latter includes the file if it
#! exists, but does not complain if it does not.
#!
#! On the 'include' line you give a path to the file to be included.  This
#! path has to be in Linux format -- ie separators are '/', and you can use
#! '.' and '..' if you wish (with some limitations).  The main remaining
#! issue is how to start the path.
#!
#! A path starting $common/ refers to files in the resources section of this
#! JAR.  Thus $common/ReferenceFormats/referenceFormatVernacularDefaults.conf
#! points to a file of the given name in the ReferenceFormats subfolder of the
#! Resources section.  This is the only case where use of '..' is restricted:
#! you can't use '..' to take you up above where $common points (because there
#! _is_ nothing above it).
#!
#! With the other options, there is no such limitation.  The other options are:
#!
#! $root/      Points to the root folder for the text (which you specify on the
#!             command line when running the converter, via the rootFolder
#!             parameter.
#!
#! $metadata/  Points to the Metadata folder.
#!
#! Other       If this is an absolute path (eg C:/MyFolder/myConf.conf) then
#!             that path is used.  If it is a relative path
#!             (eg YourFolder/yourConf.conf), it is taken as being relative
#!             to the file currently being processed.  So if you do indeed
#!             have the value YourFolder/yourConf.conf and are processing
#!             C:/MyFolder/myConf.conf when you encounter the include, the
#!             file to be processed is C:/MyFolder/YourFolder.yourConf.conf.
#!
#!
#!
#! Aside from the convenience of being able to group related configuration
#! information into its own file, the include mechanism also lets you store
#! information likely to be common to many texts all in one place, and then
#! access it from all of them.
#!
#! Potentially this means that a lot of different files may be involved, and in
#! this situation it is more than likely that you may have more than one definition
#! for a particular configuration item.  (This is actually a Good Thing, because it
#! makes it possible to have standard default definitions for items, but then
#! override them when necessary.)
#!
#! Where multiple definitions for a given item appear, the
#!
#!  .----------------.  .----------------.  .----------------.  .----------------. 
#! | .--------------. || .--------------. || .--------------. || .--------------. |
#! | |   _____      | || |      __      | || |    _______   | || |  _________   | |
#! | |  |_   _|     | || |     /  \     | || |   /  ___  |  | || | |  _   _  |  | |
#! | |    | |       | || |    / /\ \    | || |  |  (__ \_|  | || | |_/ | | \_|  | |
#! | |    | |   _   | || |   / ____ \   | || |   '.___`-.   | || |     | |      | |
#! | |   _| |__/ |  | || | _/ /    \ \_ | || |  |`\____) |  | || |    _| |_     | |
#! | |  |________|  | || ||____|  |____|| || |  |_______.'  | || |   |_____|    | |
#! | |              | || |              | || |              | || |              | |
#! | '--------------' || '--------------' || '--------------' || '--------------' |
#!  '----------------'  '----------------'  '----------------'  '----------------' 
#!
#! one to be encountered takes precedence unless you indicate otherwise.  We
#! discuss how you can do that shortly.
#!
#!
#!
#!
#!
#! Basic syntax
#! ============
#!
#! The syntax comprises a few different kinds of elements:
#!
#! - Comments.  The comment marker is #!.  Any text after this to the end
#!   of the line is ignored, along with any blanks immediately prior it.
#!   If the result is empty, the line is ignored in its entirety.
#!
#!
#! - Blank lines.  These are ignored.
#!
#!
#! - Lines of the form stepTagTranslation=... eg
#!
#!     stepTagTranslation=(usx=Ͼchar:bditϿ osis=Ͼ<hi type='bold'><hi type='italic'>Ͽ)
#!
#!   set out details of what OSIS tag should be generated for a given USX tag
#!   (where the relationship is simple enough for a straightforward mapping
#!   to suffice).  There's a lot to say about this -- see the file
#!   usxToOsisTagConversionsEtc.conf if you need more information (although
#!   hopefully normally you won't).
#!
#!
#! - $include / $includeIfExists (as discussed above).
#!
#!
#! - Lines which include '@getExternal'.  These are concerned with situations
#!   where configuration information is available from external sources, such as
#!   the metadata.xml files supplied by DBL.  For details, refer to the file
#!   PerTextRepositoryOrganisation/Dbl.conf in this JAR file.
#!
#!
#! * Definitions of the form key=value associate a value with the given
#!   key.  You _can_ have any key you like, but there's little point in
#!   introducing keys of your own (other than perhaps to hold intermediate
#!   values), because the processing uses only keys which it knows about,
#!   and all of these appear in the various configuration files in the
#!   Resources section of this JAR file.
#!
#!   There is also a variant form of this statement -- key#=value.  The '#'
#!   means 'force'.  In this case, the value overrides which has already
#!   been established, and will _not_ be overridden by any definitions
#!   encountered later in the processing.
#!
#!
#!
#!
#!
#! Values
#! ======
#!
#! I said above that the syntax for defining a configuration value is of the
#! form key=value.
#!
#! The simplest form of 'value' is just any old plain text string, in which
#! case that is the value which is used.
#!
#! Spaces at the start and end of a definition are trimmed off, so that
#! 'myThing=   Some text   ' is exactly the same as 'myThing=Some text'.
#! Spaces within the body of the definition are retained as-is, however,
#! so that 'myThing=Some     text' defines myThing as being a string
#! with a lot of spaces in the middle.  If you need to force spaces at
#! the front or end of the definition to be respected, give them as
#! '{space}'.
#!
#! Definitions which lack a right-hand side (myThing=   or myThing#=   )
#! associate an empty string with the key.  For the sake of clarity, you
#! can also give the right-hand side as {empty} to achieve the same effect.
#!
#!
#! There are also some more complicated things which can be embedded in the
#! strongs which make up the right-hand side:
#!
#!   @(parmNameA, parmNameB, ..., =dflt)
#!   @choose(valA, valB, ..., =dflt)
#!   @getExternal(pathA, PathB, ..., =dflt)
#!
#! You can have as many of these as you want within a single definition, and
#! you can also nest them as deep as you like within reason -- eg:
#!
#!   @choose( @(myImportantParameter), @getExternal(metadata, DBLMetadata/thing), =DEFAULT VALUE)
#!
#! @() works left to right looking up each parameter in the config data.
#! If it finds one which gives a non-null value, it returns that.  Otherwise it
#! returns the default value if one is specified (the default value is
#! optional).  Note that the default value is a literal -- it is not subject to
#! any processing.
#!
#! @choose selects from a number of options.  It works much the same as @(),
#! except that it simply looks at its arguments -- it does not take their
#! values and look them up.
#!
#! @getExternal obtains information from an external metadata file.  Using this
#! feature means we can take data direct from the external source, rather than
#! having to transcribe it manually.
#!
#! In order to work with external metadata, the converter needs to contain
#! appropriate processing, and we need some configuration data to say how to
#! locate the various items we might need.  For example, the processing needs to
#! know the English name of the text being processed.  For an arbitrary text we
#! might have to work that out for ourselves and perhaps store it in our
#! config.conf file.  For DBL (which presently is the one source for which we do
#! have the necessary processing and configuration information) the processing
#! can pick it up automatically from a particular field in the metadata.xml file.
#!
#! Before using this facility, the configuration information has to indicate
#! the path to the external file which supplies the data.  For DBL, this would
#! involve a line like :-
#!
#!   stepExternalDataSource=dbl:metadata:$metadata/metadata.xml
#!
#! where the right-hand side indicates the type of external data (dbl), and the path
#! ($metadata/metadata.xml), and the middle bit gives a logical name by which we refer
#! to this file when picking up data (metadata).  Anything reasonable here will do:
#! there's nothing special about the name 'metadata'.
#!
#! there is also an ifExists form eg:
#!
#!  stepExternalDataSourceIfExists=dbl:licence:$metadata/license.xml
#!
#! In this case, I associate the name 'licence' with DBL's license.xml file if it
#! exists.
#!
#!
#! Having done this, you can now use @getExternal to obtain data from these data
#! sources -- eg
#!
#!   stepAbbreviationLocal=@getExternal(metadata, DBLMetadata/identification/abbreviation)
#!
#! which says to look in the file associated with the name 'metadata' and
#! extract data using the parameter DBLMetadata/identification/abbreviation,
#! which in this case is used as an xpath by the DBL processing.
#!
#! As with @(...), you can give a number of alternative parameters and
#! optionally a default if you wish:
#!
#!   stepAbbreviationLocal=@getExternal(metadata, DBLMetadata/a, DBLMetadata/b, =Dunno)
#!
#!
#! Note that substitutions are made at the time the data is _requested_, not
#! when the configuration data is loaded.  So if, immediately after loading
#! the configuration data, a particular key 'myName' is associated with
#! 'John', and if another key 'hi' is associated with 'Hi, I'm @(myName)',
#! querying 'hi' immediately after the data load will give 'Hi, I'm John'.
#! But if the processing then sets 'myName' to 'Mary', querying 'hi' after that
#! point will return 'Hi, I'm Mary'.
#!
#! Finally, there are a few built-in configuration parameters which are
#! generated by the processing, rather than being held in configuration
#! parameters.  You may need to be a bit careful accessing these, since in
#! some cases the values cannot be determined until later on in the processing:
#!
#! - stepExtendedLanguageCode: 2-char language or 3-char code if there is no
#!   2-char code, along with script code and country code where applicable.
#!
#! - stepForceVersePerLine: 'Yes' if we need to force verse-per-line.  This was
#!   an issue at one point with RTL texts, because a bug in STEP meant these
#!   displayed correctly only with verse-per-line.  I believe this _may_ now
#!   have been fixed.
#!
#! - stepModuleName: What it says on the tin.
#!
#! - stepTextDirection / stepTextDirectionForSword: The former is LTR or RTL.
#!   The Sword version is LToR or RToL.
#!
#! - stepTextModifiedDate: Format: yyyy-mm-dd.
#!
#! - stepVersificationScheme: The name of the versification scheme being used.
#!
#!
#!
#!
#!
#! Miscellaneous
#! =============
#!
#! * Command line parameters are written to the configuration data repository,
#!   so they can be treated like any other configuration parameter.  They are
#!   set using 'force' and will therefore override any settings of your own,
#!   and any already in the configuration files.
#!
#! * There are some calculated values which can be accessed as though they
#!   were ordinary configuration parameters.  These all have 'calc' in their
#!   key names.  These can be a little difficult to use, because they
#!   become available only after the processing which generates them has
#!   run, so you have to know when it is safe to attempt to access them.
#!
#!
#!
#!
#!
#! Obtaining data from external sources
#! ====================================
#!

#!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
